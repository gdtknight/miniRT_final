# Tasks: BVH Tree Visualization Improvements

**Feature**: 015-bvh-viz-improvements  
**Input**: Design documents from `/specs/015-bvh-viz-improvements/`  
**Prerequisites**: plan.md âœ“, spec.md âœ“, research.md âœ“, data-model.md âœ“, contracts/ âœ“, quickstart.md âœ“

**Organization**: Tasks are grouped by user story to enable independent implementation and testing of each story.

## Format: `- [ ] [ID] [P?] [Story] Description`

- **[P]**: Can run in parallel (different files, no dependencies)
- **[Story]**: Which user story this task belongs to (e.g., US1, US2)
- Include exact file paths in descriptions

## Path Conventions

- **Single project**: `src/`, `includes/`, `tests/` at repository root
- All paths are absolute from miniRT repository root

---

## Phase 1: Setup (Data Structure Modifications)

**Purpose**: Add object identifier storage infrastructure

- [ ] T001 Add char id[8] field to t_sphere struct in includes/objects.h
- [ ] T002 Add char id[8] field to t_plane struct in includes/objects.h
- [ ] T003 Add char id[8] field to t_cylinder struct in includes/objects.h
- [ ] T004 Create includes/format_object_id.h header with format_object_id() function signature and t_obj_type enum
- [ ] T005 Create includes/window/window_debounce.h header with timer state machine enums (TIMER_IDLE/PENDING/RENDERING) and data structures (t_timer_slot, t_timer_pool, t_input_queue, t_progress_bar)

**Checkpoint**: All header changes complete, data structures defined

---

## Phase 2: Foundational (Object ID Generation & Utilities)

**Purpose**: Core infrastructure for object identification - MUST be complete before ANY user story display integration

**âš ï¸ CRITICAL**: No user story work can begin until this phase is complete

- [ ] T006 [P] Create src/utils/format_object_id.c implementing format_object_id(char *buffer, t_obj_type type, int index) per contract spec
- [ ] T007 [P] Create src/utils/get_object_type_prefix.c implementing get_object_type_prefix(t_obj_type type) returning "sp", "pl", or "cy"
- [ ] T008 Modify src/parser/parse_sphere.c to generate object ID using format_object_id() and store in sphere.id[8] field during parsing
- [ ] T009 Modify src/parser/parse_plane.c to generate object ID using format_object_id() and store in plane.id[8] field during parsing
- [ ] T010 Modify src/parser/parse_cylinder.c to generate object ID using format_object_id() and store in cylinder.id[8] field during parsing
- [ ] T011 Add static counters for sphere_count, plane_count, cylinder_count in src/parser/parse_objects.c to track sequential numbering per type
- [ ] T012 Modify src/parser/parse_validation.c to validate object ID format (lowercase type prefix, hyphen separator, numeric suffix)

**Checkpoint**: All objects now have identifiers generated during parsing - foundation ready

---

## Phase 3: User Story 1 - Unified Object Identification (Priority: P1) ðŸŽ¯ MVP

**Goal**: Display consistent lowercase object identifiers (sp-1, pl-2, cy-3) in both HUD and BVH tree visualization

**Independent Test**: Load scene with multiple objects, view HUD (press H) and BVH tree (press V), verify identifiers match exactly (e.g., "sp-1" in HUD == "sp-1" in tree leaf nodes)

### Implementation for User Story 1

- [ ] T013 [P] [US1] Modify src/hud/hud_objects.c render_sphere_info() to display sphere.id instead of generating "Sphere #N" format
- [ ] T014 [P] [US1] Modify src/hud/hud_objects.c render_plane_info() to display plane.id instead of generating "Plane #N" format
- [ ] T015 [P] [US1] Modify src/hud/hud_objects.c render_cylinder_info() to display cylinder.id instead of generating "Cylinder #N" format
- [ ] T016 [P] [US1] Modify src/bvh_vis/bvh_vis_node.c format_object_list() to display object IDs from object.id field in leaf nodes
- [ ] T017 [US1] Update src/bvh_vis/bvh_vis_render.c to use object identifiers when rendering BVH tree leaf node labels

**Checkpoint**: User Story 1 complete - HUD and BVH tree show identical object identifiers

---

## Phase 4: User Story 2 - Smooth Keyboard Navigation (Priority: P2)

**Goal**: Implement 1-second debounce mechanism with state machine, timer pool, input queue, and progress bar to eliminate rendering stuttering during rapid keyboard input

**Independent Test**: Rapidly press any keyboard keys (10+ times within 2 seconds), verify no visual stuttering and single smooth render occurs 1 second after input stops

### Timer Infrastructure for User Story 2

- [ ] T018 [P] [US2] Create src/debounce/debounce_init.c implementing init_timer_pool(t_timer_pool *pool) to initialize 4 timer slots per contract spec
- [ ] T019 [P] [US2] Create src/debounce/debounce_timer.c implementing get_timer(t_timer_pool *pool, t_timer_id id) and get_timestamp_usec() using gettimeofday()
- [ ] T020 [P] [US2] Create src/debounce/debounce_state.c implementing reset_timer(), is_timer_expired(), start_rendering(), finish_rendering() per state machine transitions
- [ ] T021 [P] [US2] Create src/debounce/debounce_queue.c implementing enqueue_input(), dequeue_input(), process_input_queue() for 8-slot circular buffer

### State Machine Integration for User Story 2

- [ ] T022 [US2] Modify src/window/handle_key.c to route keyboard navigation inputs through debounce timer (check state, enqueue if RENDERING, reset timer if IDLE/PENDING)
- [ ] T023 [US2] Modify src/window/window_loop.c render loop to check is_timer_expired() and execute render only when debounce timer expires
- [ ] T024 [US2] Add render->dirty flag tracking in src/window/window_render.c to mark when scene needs re-rendering after accumulated inputs
- [ ] T025 [US2] Implement process_input_queue() call in src/window/window_loop.c after render completes to drain queued keyboard events

### Cancellation & Progress Bar for User Story 2

- [ ] T026 [P] [US2] Modify src/window/handle_mouse.c to cancel debounce timer and clear input queue on any mouse action (click, drag, scroll)
- [ ] T027 [P] [US2] Modify src/window/window_events.c to cancel debounce timer and discard pending renders on HUD/BVH view switch
- [ ] T028 [US2] Create src/hud/hud_progress.c implementing render_progress_bar() for 200Ã—20px green fill progress bar at bottom-left showing debounce countdown
- [ ] T029 [US2] Integrate progress bar rendering in src/window/window_loop.c to display when timer state is TIMER_PENDING

### Error Handling for User Story 2

- [ ] T030 [US2] Add timer pool overflow error handling in src/debounce/debounce_timer.c - return error code when >4 components attempt timer registration
- [ ] T031 [US2] Add input queue overflow handling in src/debounce/debounce_queue.c - reject and discard newest input when queue reaches 8 slots capacity
- [ ] T032 [US2] Add timer pool reset on scene reload in src/scene/scene_reset.c to clear stale timer references

**Checkpoint**: User Story 2 complete - keyboard navigation is smooth with 1-second debounce, progress bar visible, mouse/view actions cancel timer

---

## Phase 5: Polish & Cross-Cutting Concerns

**Purpose**: Testing, validation, documentation, and edge case handling

### Validation & Testing

- [ ] T033 [P] Create test scene tests/scenes/test_object_ids.rt with 3+ objects of each type to validate identifier format consistency
- [ ] T034 [P] Create test scene tests/scenes/test_debounce.rt with complex geometry to test debounce behavior during rapid keyboard interaction
- [ ] T035 Test identifier format consistency by loading test_object_ids.rt, toggling HUD (H key), toggling BVH tree (V key), and verifying all identifiers match
- [ ] T036 Test debounce timing by rapidly pressing navigation keys in test_debounce.rt scene and verifying single render occurs 1 second after last keypress
- [ ] T037 Test input queue by starting complex render, pressing keys during render, and verifying all inputs processed after render completes
- [ ] T038 Test mouse cancellation by pressing keys (timer starts), clicking mouse during debounce period, and verifying timer cancelled with queue cleared
- [ ] T039 Test view switch cancellation by pressing keys (timer starts), switching between HUD/BVH views, and verifying timer cancelled with pending renders discarded

### Memory & Error Validation

- [ ] T040 Run valgrind leak check on test_object_ids.rt and test_debounce.rt to verify zero memory leaks from new id[8] fields and timer pool
- [ ] T041 Test timer pool overflow by simulating >4 components requesting timers and verifying error code returned with graceful fallback
- [ ] T042 Test input queue overflow by simulating >8 rapid keypresses during slow render and verifying oldest inputs rejected correctly
- [ ] T043 Test invalid object identifiers in scene file by creating malformed .rt file and verifying parse error with clear error message

### Norminette & Build

- [ ] T044 [P] Run norminette on includes/objects.h, includes/format_object_id.h, includes/window/window_debounce.h and fix any violations
- [ ] T045 [P] Run norminette on src/utils/format_object_id.c, src/utils/get_object_type_prefix.c and fix any violations
- [ ] T046 [P] Run norminette on src/debounce/*.c files and fix any violations (ensure <25 line function limit)
- [ ] T047 [P] Run norminette on modified parser files (parse_sphere.c, parse_plane.c, parse_cylinder.c, parse_objects.c, parse_validation.c) and fix violations
- [ ] T048 [P] Run norminette on modified window files (handle_key.c, handle_mouse.c, window_loop.c, window_events.c, window_render.c) and fix violations
- [ ] T049 [P] Run norminette on modified HUD files (hud_objects.c, hud_progress.c) and BVH files (bvh_vis_node.c, bvh_vis_render.c) and fix violations
- [ ] T050 Update Makefile to include new source files (format_object_id.c, get_object_type_prefix.c, debounce_init.c, debounce_timer.c, debounce_state.c, debounce_queue.c, hud_progress.c)
- [ ] T051 Run make to build entire project and fix any compilation errors or warnings

### Documentation

- [ ] T052 [P] Update README.md to document new identifier format (sp-N, pl-N, cy-N) and debounce behavior (1-second delay on keyboard navigation)
- [ ] T053 Validate quickstart.md guide by following all test scenarios and verifying expected behavior matches documented results

---

## Dependencies & Execution Order

### Phase Dependencies

- **Setup (Phase 1)**: No dependencies - can start immediately
- **Foundational (Phase 2)**: Depends on Setup completion - BLOCKS all user stories
- **User Stories (Phase 3-4)**: All depend on Foundational phase completion
  - User Story 1 can proceed after Phase 2
  - User Story 2 can proceed after Phase 2 (independent of User Story 1)
- **Polish (Phase 5)**: Depends on both User Stories being complete

### User Story Dependencies

- **User Story 1 (P1)**: Can start after Foundational (Phase 2) - No dependencies on other stories
- **User Story 2 (P2)**: Can start after Foundational (Phase 2) - Independent of User Story 1, can be developed in parallel

### Within Each Phase

- **Phase 1**: T001-T003 modify same file (objects.h) so must be sequential, but T004 and T005 are independent
- **Phase 2**: T006-T007 can run in parallel (different files), T008-T010 can run in parallel (different parser files), T011-T012 sequential
- **Phase 3**: T013-T015 can run in parallel (same file, different functions), T016 can run in parallel with T017
- **Phase 4**: T018-T021 can run in parallel (different debounce files), T022-T025 sequential (same window files), T026-T027 can run in parallel, T028-T029 sequential, T030-T032 can run in parallel
- **Phase 5**: Most validation/norminette tasks can run in parallel, documentation tasks sequential

### Parallel Opportunities

- All [P] tasks within a phase can run simultaneously
- User Story 1 and User Story 2 can be developed in parallel after Phase 2 completes
- Norminette checks (T044-T049) can all run in parallel
- Test creation (T033-T034) can run in parallel

---

## Parallel Example: User Story 1

```bash
# Launch all HUD modifications together:
Task: "Modify src/hud/hud_objects.c render_sphere_info()"
Task: "Modify src/hud/hud_objects.c render_plane_info()"
Task: "Modify src/hud/hud_objects.c render_cylinder_info()"

# Launch BVH modifications in parallel:
Task: "Modify src/bvh_vis/bvh_vis_node.c format_object_list()"
```

## Parallel Example: User Story 2 Timer Infrastructure

```bash
# Launch all debounce module files together:
Task: "Create src/debounce/debounce_init.c"
Task: "Create src/debounce/debounce_timer.c"
Task: "Create src/debounce/debounce_state.c"
Task: "Create src/debounce/debounce_queue.c"
```

---

## Implementation Strategy

### MVP First (User Story 1 Only)

1. Complete Phase 1: Setup (T001-T005) â†’ Data structures ready
2. Complete Phase 2: Foundational (T006-T012) â†’ Object IDs generated
3. Complete Phase 3: User Story 1 (T013-T017) â†’ Unified identifiers working
4. **STOP and VALIDATE**: Load test scene, verify HUD and BVH show matching identifiers
5. Deploy/demo if ready

### Incremental Delivery

1. Complete Setup + Foundational â†’ All objects have identifiers
2. Add User Story 1 â†’ Test independently â†’ Consistent IDs in HUD/BVH (MVP!)
3. Add User Story 2 â†’ Test independently â†’ Smooth keyboard navigation added
4. Each story adds value without breaking previous stories

### Parallel Team Strategy

With multiple developers after Phase 2 completes:

1. Team completes Setup (Phase 1) + Foundational (Phase 2) together
2. Once Phase 2 is done:
   - Developer A: User Story 1 (T013-T017) - HUD/BVH identifier display
   - Developer B: User Story 2 (T018-T032) - Debounce timer system
3. Stories complete and integrate independently

---

## Summary Statistics

- **Total Tasks**: 53
- **Setup Phase**: 5 tasks
- **Foundational Phase**: 7 tasks (blocking)
- **User Story 1 (P1)**: 5 tasks (MVP)
- **User Story 2 (P2)**: 15 tasks
- **Polish Phase**: 21 tasks (validation, norminette, docs)

### Tasks Per Category

- **Data structures**: 5 tasks (T001-T005)
- **Object ID generation**: 7 tasks (T006-T012)
- **Display integration**: 5 tasks (T013-T017)
- **Debounce infrastructure**: 14 tasks (T018-T031)
- **Cancellation & UI**: 1 task (T032)
- **Testing & validation**: 11 tasks (T033-T043)
- **Code quality**: 7 tasks (T044-T049)
- **Build & documentation**: 3 tasks (T050-T052)
- **Final validation**: 1 task (T053)

### Parallel Opportunities Identified

- **Phase 2**: Up to 4 tasks in parallel (T006-T007, T008-T010)
- **Phase 3**: Up to 3 tasks in parallel (T013-T015)
- **Phase 4**: Up to 4 tasks in parallel (T018-T021, T026-T027)
- **Phase 5**: Up to 6 norminette tasks in parallel (T044-T049)
- **Cross-story**: User Story 1 and 2 can be developed in parallel after Phase 2

### Independent Test Criteria

- **User Story 1**: Load scene â†’ Toggle HUD (H) â†’ Toggle BVH (V) â†’ Verify identifier format matches exactly
- **User Story 2**: Load scene â†’ Rapidly press navigation keys 10+ times â†’ Verify single render 1 second after last keypress â†’ Verify progress bar visible during debounce

### Suggested MVP Scope

**MVP = User Story 1 (P1 - Unified Object Identification)**
- Phases 1 + 2 + 3 = Tasks T001-T017
- Deliverable: Consistent lowercase object identifiers across HUD and BVH tree
- Testable: Load scene, verify "sp-1" format appears identically in both displays
- Value: Enables efficient debugging by eliminating mental conversion between naming conventions

**Post-MVP = User Story 2 (P2 - Smooth Keyboard Navigation)**
- Phase 4 = Tasks T018-T032
- Deliverable: 1-second debounce eliminates rendering stuttering during rapid keyboard interaction
- Testable: Rapid key presses result in single smooth render after input stops
- Value: Significantly improves user experience during intensive exploration sessions

---

## Notes

- [P] tasks = different files, no dependencies within phase
- [US1]/[US2] labels map tasks to specific user stories for traceability
- Each user story should be independently completable and testable
- All new code MUST pass norminette (zero violations)
- All changes MUST pass valgrind (zero memory leaks)
- Commit after each task or logical group
- Stop at any checkpoint to validate story independently
- 42 School constraints: Only allowed functions (gettimeofday, snprintf, mlx_*), no pthread, no dynamic allocation during runtime
