# 레이 트레이싱 알고리즘

레이 트레이싱(Ray Tracing)은 광선의 경로를 역추적하여 사실적인 이미지를 생성하는 렌더링 기법입니다.

---

## 📖 기본 원리

### 광선 추적의 개념

실제 세계에서는 광원에서 나온 빛이 물체에 반사되어 눈(카메라)에 도달합니다. 하지만 레이 트레이싱은 이를 역방향으로 계산합니다:

```
눈(카메라) → 장면의 물체 → 광원
```

이렇게 하는 이유는 효율성 때문입니다. 광원에서 나온 대부분의 광선은 카메라에 도달하지 않지만, 카메라에서 출발한 광선은 반드시 화면의 픽셀과 대응됩니다.

### 알고리즘 흐름

```
for 각 픽셀 (x, y):
    1. 카메라에서 픽셀 방향으로 광선 생성
    2. 광선과 교차하는 가장 가까운 객체 찾기
    3. 교차점에서 조명 계산:
        - Ambient (주변광)
        - Diffuse (난반사)
        - Specular (정반사)
        - Shadow (그림자)
    4. 픽셀 색상 결정
```

---

## 🔍 광선 생성 (Ray Generation)

### 카메라 좌표계

카메라는 다음 요소로 정의됩니다:
- **위치 (origin)**: 카메라의 3D 공간 좌표
- **방향 (direction)**: 카메라가 바라보는 방향
- **FOV (field of view)**: 시야각 (0-180°)

### 직교 정규 기저 (Orthonormal Basis)

카메라 방향벡터로부터 3개의 직교하는 단위벡터를 생성합니다:

```c
// forward: 카메라 방향
vec3 forward = normalize(camera.direction);

// 임시 up 벡터
vec3 temp_up = (0, 1, 0);  // 월드 Y축

// right: forward와 up의 외적
vec3 right = normalize(cross(forward, temp_up));

// up: right와 forward의 외적
vec3 up = cross(right, forward);
```

### 픽셀별 광선

각 픽셀 (x, y)에 대해:

```c
// 화면 좌표를 [-1, 1] 범위로 정규화
float ndc_x = (2.0 * x / width) - 1.0;
float ndc_y = 1.0 - (2.0 * y / height);

// 종횡비 보정
float aspect = width / height;
ndc_x *= aspect;

// FOV를 tan 값으로 변환
float fov_tan = tan(fov * 0.5 * PI / 180.0);

// 광선 방향 계산
vec3 ray_dir = normalize(
    forward +
    right * ndc_x * fov_tan +
    up * ndc_y * fov_tan
);

// 광선 생성
ray = { origin: camera.position, direction: ray_dir };
```

---

## 🎯 광선-객체 교차 검사

### 1. 광선-구체 교차

구체: 중심 C, 반지름 r
광선: 원점 O, 방향 D, 거리 t

**수학적 정의**:
```
점 P = O + t * D 가 구체 위에 있다면:
|P - C|² = r²

전개:
|O + tD - C|² = r²
(O - C + tD) · (O - C + tD) = r²

L = O - C 라고 하면:
(L + tD) · (L + tD) = r²
L·L + 2t(D·L) + t²(D·D) = r²

D는 단위벡터이므로 D·D = 1:
t² + 2t(D·L) + (L·L - r²) = 0
```

**이차방정식 해**:
```
a = 1
b = 2 * dot(D, L)
c = dot(L, L) - r²

판별식 Δ = b² - 4ac

if Δ < 0: 교차 없음
if Δ = 0: 한 점에서 접함
if Δ > 0: 두 점에서 교차

t = (-b ± sqrt(Δ)) / 2a
```

**구현**:
```c
bool intersect_sphere(ray, sphere, *t_out)
{
    vec3 oc = sub(ray.origin, sphere.center);
    float a = 1.0;  // ray.dir is normalized
    float b = 2.0 * dot(ray.dir, oc);
    float c = dot(oc, oc) - sphere.radius * sphere.radius;
    
    float discriminant = b * b - 4 * a * c;
    if (discriminant < 0)
        return false;
    
    float sqrt_d = sqrt(discriminant);
    float t1 = (-b - sqrt_d) / (2 * a);
    float t2 = (-b + sqrt_d) / (2 * a);
    
    // 가장 가까운 양수 t 선택
    float t = (t1 > 0) ? t1 : t2;
    if (t <= 0)
        return false;
    
    *t_out = t;
    return true;
}
```

### 2. 광선-평면 교차

평면: 점 P0, 법선 N
광선: 원점 O, 방향 D

**수학적 정의**:
```
평면 위의 점 P는:
(P - P0) · N = 0

광선 위의 점:
P = O + tD

대입:
(O + tD - P0) · N = 0
(O - P0) · N + t(D · N) = 0

t = -((O - P0) · N) / (D · N)
```

**구현**:
```c
bool intersect_plane(ray, plane, *t_out)
{
    float denom = dot(ray.dir, plane.normal);
    
    // 광선이 평면과 평행
    if (fabs(denom) < EPSILON)
        return false;
    
    vec3 p0_to_origin = sub(plane.point, ray.origin);
    float t = dot(p0_to_origin, plane.normal) / denom;
    
    if (t <= 0)
        return false;
    
    *t_out = t;
    return true;
}
```

### 3. 광선-원기둥 교차

원기둥: 중심 C, 축 방향 A, 반지름 r, 높이 h

원기둥 교차는 3부분으로 나뉩니다:
1. **원통면 (Cylindrical Surface)**
2. **상단 캡 (Top Cap)**
3. **하단 캡 (Bottom Cap)**

#### 3.1 원통면 교차

```c
// 광선을 원기둥 축 기준으로 투영
vec3 oc = sub(ray.origin, cylinder.center);
vec3 axis = cylinder.axis;  // 정규화된 축 방향

// 축 방향 성분 제거 (2D 원 문제로 환원)
float dot_d_axis = dot(ray.dir, axis);
float dot_oc_axis = dot(oc, axis);

vec3 d_perp = sub(ray.dir, scale(axis, dot_d_axis));
vec3 oc_perp = sub(oc, scale(axis, dot_oc_axis));

// 2D 원과의 교차 (구체와 유사)
float a = dot(d_perp, d_perp);
float b = 2.0 * dot(d_perp, oc_perp);
float c = dot(oc_perp, oc_perp) - cylinder.radius * cylinder.radius;

float discriminant = b * b - 4 * a * c;
if (discriminant < 0)
    return false;

// t 값 계산
float t = (-b - sqrt(discriminant)) / (2 * a);

// 높이 제한 확인
vec3 hit_point = add(ray.origin, scale(ray.dir, t));
vec3 hit_to_center = sub(hit_point, cylinder.center);
float height_proj = dot(hit_to_center, axis);

if (height_proj < 0 || height_proj > cylinder.height)
    return false;  // 원통면을 벗어남
```

#### 3.2 캡 교차

```c
// 상단 캡 (평면 교차)
vec3 top_center = add(cylinder.center, 
                      scale(axis, cylinder.height));
plane top_cap = { point: top_center, normal: axis };

if (intersect_plane(ray, top_cap, &t))
{
    vec3 hit = add(ray.origin, scale(ray.dir, t));
    vec3 to_center = sub(hit, top_center);
    
    // 원 안에 있는지 확인
    if (dot(to_center, to_center) <= cylinder.radius * cylinder.radius)
        return true;  // 상단 캡에 교차
}

// 하단 캡 (유사)
```

---

## 🔎 최근접 객체 찾기

모든 객체와 교차 검사를 수행하고 가장 가까운 객체를 선택합니다:

```c
hit_record find_nearest_hit(ray, scene)
{
    hit_record nearest;
    nearest.t = INFINITY;
    nearest.hit = false;
    
    // 모든 구체 검사
    for (sphere in scene.spheres)
    {
        float t;
        if (intersect_sphere(ray, sphere, &t) && t < nearest.t)
        {
            nearest.t = t;
            nearest.object = sphere;
            nearest.hit = true;
        }
    }
    
    // 모든 평면 검사
    for (plane in scene.planes) { /* 유사 */ }
    
    // 모든 원기둥 검사
    for (cylinder in scene.cylinders) { /* 유사 */ }
    
    return nearest;
}
```

---

## ⚡ BVH 가속 구조 (Bounding Volume Hierarchy)

### 개요

BVH는 공간 분할 기법으로 광선-객체 교차 검사를 O(n)에서 O(log n)으로 최적화하여 복잡한 장면에서 2-10배의 렌더링 속도 향상을 제공합니다. v2.1.0부터 기본적으로 활성화되어 있습니다.

### 기본 개념

복잡한 장면에서는 모든 객체를 순차적으로 검사하면 매우 느립니다. BVH는 객체들을 계층적 이진 트리로 구성하여 광선이 닿지 않는 영역을 빠르게 제외합니다.

```
            [루트 AABB]
           /           \
    [왼쪽 AABB]    [오른쪽 AABB]
      /    \          /      \
  [obj1] [obj2]   [obj3]   [obj4]
```

### 알고리즘

#### 트리 구축 (Build)

BVH 트리는 재귀적으로 구축됩니다:

1. **장면 경계 계산**: 모든 객체를 포함하는 AABB 계산
2. **분할 축 선택**: 가장 긴 공간 축(X, Y, Z 중) 선택
3. **중간점 분할**: 선택한 축의 중간점에서 객체를 좌/우로 분할
4. **재귀적 세분화**: 각 자식 노드에 대해 1-3 반복
5. **리프 노드 생성**: 8개 이하의 객체는 리프 노드로 저장

**구현 예시**:
```c
bvh_node build_bvh(objects[], count)
{
    // 리프 노드 조건
    if (count <= 8)
        return create_leaf_node(objects, count);
    
    // 경계 상자 계산
    aabb bounds = compute_aabb(objects, count);
    
    // 가장 긴 축 선택
    int axis = longest_axis(bounds);  // 0=X, 1=Y, 2=Z
    
    // 중간점 기준 정렬
    sort_by_centroid(objects, count, axis);
    int mid = count / 2;
    
    // 재귀적으로 자식 노드 생성
    bvh_node left = build_bvh(objects[0..mid], mid);
    bvh_node right = build_bvh(objects[mid..count], count - mid);
    
    return create_internal_node(bounds, left, right);
}
```

#### 트리 순회 (Traversal)

광선과 BVH 트리의 교차 검사:

1. **AABB 교차 검사**: 광선이 노드의 경계 상자와 교차하는지 확인
2. **조기 종료**: 교차하지 않으면 해당 노드의 하위 트리 전체 건너뜀
3. **리프 노드 처리**: 리프 노드에 도달하면 모든 객체와 직접 교차 검사
4. **재귀적 탐색**: 내부 노드는 양쪽 자식 노드를 재귀적으로 탐색
5. **최근접 선택**: 가장 가까운 교차점 반환

**구현 예시**:
```c
hit_record traverse_bvh(ray, node)
{
    // AABB와 교차하지 않으면 건너뜀 (조기 종료)
    if (!intersect_aabb(ray, node.aabb))
        return NO_HIT;
    
    // 리프 노드: 객체와 직접 교차 검사
    if (node.is_leaf)
    {
        hit_record nearest = NO_HIT;
        for (obj in node.objects)
        {
            hit_record hit = intersect_object(ray, obj);
            if (hit.t < nearest.t)
                nearest = hit;
        }
        return nearest;
    }
    
    // 내부 노드: 자식 노드 순회
    hit_record left_hit = traverse_bvh(ray, node.left);
    hit_record right_hit = traverse_bvh(ray, node.right);
    
    // 가장 가까운 교차점 반환
    return (left_hit.t < right_hit.t) ? left_hit : right_hit;
}
```

### 광선-AABB 교차 검사

AABB (Axis-Aligned Bounding Box)는 축에 정렬된 경계 상자입니다. 효율적인 교차 검사를 위해 슬랩 방법(slab method)을 사용합니다:

```c
bool intersect_aabb(ray, aabb)
{
    float t_min = -INFINITY;
    float t_max = INFINITY;
    
    // 각 축(X, Y, Z)마다 교차 구간 계산
    for (int axis = 0; axis < 3; axis++)
    {
        float inv_d = 1.0 / ray.dir[axis];
        float t0 = (aabb.min[axis] - ray.origin[axis]) * inv_d;
        float t1 = (aabb.max[axis] - ray.origin[axis]) * inv_d;
        
        // 광선 방향이 음수면 t0, t1 교환
        if (inv_d < 0)
            swap(t0, t1);
        
        // 교차 구간 갱신
        t_min = max(t_min, t0);
        t_max = min(t_max, t1);
        
        // 교차 구간이 비어있으면 교차 없음
        if (t_max < t_min)
            return false;
    }
    
    // 교차 구간이 양수 범위에 있어야 함
    return t_max > 0;
}
```

### 데이터 구조

**t_bvh_node** - BVH 트리 노드:
- `aabb`: 경계 상자 (모든 자식 객체를 포함)
- `is_leaf`: 리프 노드 여부
- `objects[]`: 리프 노드의 객체 리스트 (최대 8개)
- `left`, `right`: 자식 노드 포인터 (내부 노드만)

**t_aabb** - 축 정렬 경계 상자:
- `min`: 최소 3D 좌표 (x, y, z)
- `max`: 최대 3D 좌표 (x, y, z)

### 복잡도 분석

**BVH 없음 (Brute-force)**:
- 시간 복잡도: O(n) - 모든 객체 검사
- 공간 복잡도: O(1) - 추가 메모리 없음

**BVH 사용**:
- 트리 구축: O(n log n) - 재귀적 분할
- 트리 순회: O(log n) - 이진 트리 탐색
- 공간 복잡도: O(n) - 트리 노드 저장 (~80 bytes/node)

### 성능

**속도 향상**:
- 복잡한 장면(50+ 객체): 2-10배 렌더링 속도 향상
- 간단한 장면(<10 객체): 오버헤드로 약간 느려질 수 있음
- 최적 성능: 객체가 공간적으로 분산된 장면

**메모리 오버헤드**:
- 객체당 약 80 bytes (BVH 노드 구조)
- 100개 객체 장면: ~8 KB 추가 메모리
- 1000개 객체 장면: ~80 KB 추가 메모리

**사용법**:
- v2.1.0부터 기본 활성화
- 별도 설정 불필요
- 모든 객체 타입(구, 평면, 원기둥) 지원

*참고: 성능 수치는 장면 복잡도와 객체 분포에 따라 달라질 수 있습니다.*

---

## 🔗 관련 문서

- [조명 시스템](조명-시스템.md)
- [프로그램 개요](프로그램-개요.md)
- [인터랙티브 컨트롤](인터랙티브-컨트롤.md)

---

**Last Updated**: 2026-01  
**Version**: 2.1.0
