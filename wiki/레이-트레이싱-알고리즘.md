# ë ˆì´ íŠ¸ë ˆì´ì‹± ì•Œê³ ë¦¬ì¦˜

ë ˆì´ íŠ¸ë ˆì´ì‹±(Ray Tracing)ì€ ê´‘ì„ ì˜ ê²½ë¡œë¥¼ ì—­ì¶”ì í•˜ì—¬ ì‚¬ì‹¤ì ì¸ ì´ë¯¸ì§€ë¥¼ ìƒì„±í•˜ëŠ” ë Œë”ë§ ê¸°ë²•ì…ë‹ˆë‹¤.

---

## ğŸ“– ê¸°ë³¸ ì›ë¦¬

### ê´‘ì„  ì¶”ì ì˜ ê°œë…

ì‹¤ì œ ì„¸ê³„ì—ì„œëŠ” ê´‘ì›ì—ì„œ ë‚˜ì˜¨ ë¹›ì´ ë¬¼ì²´ì— ë°˜ì‚¬ë˜ì–´ ëˆˆ(ì¹´ë©”ë¼)ì— ë„ë‹¬í•©ë‹ˆë‹¤. í•˜ì§€ë§Œ ë ˆì´ íŠ¸ë ˆì´ì‹±ì€ ì´ë¥¼ ì—­ë°©í–¥ìœ¼ë¡œ ê³„ì‚°í•©ë‹ˆë‹¤:

```
ëˆˆ(ì¹´ë©”ë¼) â†’ ì¥ë©´ì˜ ë¬¼ì²´ â†’ ê´‘ì›
```

ì´ë ‡ê²Œ í•˜ëŠ” ì´ìœ ëŠ” íš¨ìœ¨ì„± ë•Œë¬¸ì…ë‹ˆë‹¤. ê´‘ì›ì—ì„œ ë‚˜ì˜¨ ëŒ€ë¶€ë¶„ì˜ ê´‘ì„ ì€ ì¹´ë©”ë¼ì— ë„ë‹¬í•˜ì§€ ì•Šì§€ë§Œ, ì¹´ë©”ë¼ì—ì„œ ì¶œë°œí•œ ê´‘ì„ ì€ ë°˜ë“œì‹œ í™”ë©´ì˜ í”½ì…€ê³¼ ëŒ€ì‘ë©ë‹ˆë‹¤.

### ì•Œê³ ë¦¬ì¦˜ íë¦„

```
for ê° í”½ì…€ (x, y):
    1. ì¹´ë©”ë¼ì—ì„œ í”½ì…€ ë°©í–¥ìœ¼ë¡œ ê´‘ì„  ìƒì„±
    2. ê´‘ì„ ê³¼ êµì°¨í•˜ëŠ” ê°€ì¥ ê°€ê¹Œìš´ ê°ì²´ ì°¾ê¸°
    3. êµì°¨ì ì—ì„œ ì¡°ëª… ê³„ì‚°:
        - Ambient (ì£¼ë³€ê´‘)
        - Diffuse (ë‚œë°˜ì‚¬)
        - Specular (ì •ë°˜ì‚¬)
        - Shadow (ê·¸ë¦¼ì)
    4. í”½ì…€ ìƒ‰ìƒ ê²°ì •
```

---

## ğŸ” ê´‘ì„  ìƒì„± (Ray Generation)

### ì¹´ë©”ë¼ ì¢Œí‘œê³„

ì¹´ë©”ë¼ëŠ” ë‹¤ìŒ ìš”ì†Œë¡œ ì •ì˜ë©ë‹ˆë‹¤:
- **ìœ„ì¹˜ (origin)**: ì¹´ë©”ë¼ì˜ 3D ê³µê°„ ì¢Œí‘œ
- **ë°©í–¥ (direction)**: ì¹´ë©”ë¼ê°€ ë°”ë¼ë³´ëŠ” ë°©í–¥
- **FOV (field of view)**: ì‹œì•¼ê° (0-180Â°)

### ì§êµ ì •ê·œ ê¸°ì € (Orthonormal Basis)

ì¹´ë©”ë¼ ë°©í–¥ë²¡í„°ë¡œë¶€í„° 3ê°œì˜ ì§êµí•˜ëŠ” ë‹¨ìœ„ë²¡í„°ë¥¼ ìƒì„±í•©ë‹ˆë‹¤:

```c
// forward: ì¹´ë©”ë¼ ë°©í–¥
vec3 forward = normalize(camera.direction);

// ì„ì‹œ up ë²¡í„°
vec3 temp_up = (0, 1, 0);  // ì›”ë“œ Yì¶•

// right: forwardì™€ upì˜ ì™¸ì 
vec3 right = normalize(cross(forward, temp_up));

// up: rightì™€ forwardì˜ ì™¸ì 
vec3 up = cross(right, forward);
```

### í”½ì…€ë³„ ê´‘ì„ 

ê° í”½ì…€ (x, y)ì— ëŒ€í•´:

```c
// í™”ë©´ ì¢Œí‘œë¥¼ [-1, 1] ë²”ìœ„ë¡œ ì •ê·œí™”
float ndc_x = (2.0 * x / width) - 1.0;
float ndc_y = 1.0 - (2.0 * y / height);

// ì¢…íš¡ë¹„ ë³´ì •
float aspect = width / height;
ndc_x *= aspect;

// FOVë¥¼ tan ê°’ìœ¼ë¡œ ë³€í™˜
float fov_tan = tan(fov * 0.5 * PI / 180.0);

// ê´‘ì„  ë°©í–¥ ê³„ì‚°
vec3 ray_dir = normalize(
    forward +
    right * ndc_x * fov_tan +
    up * ndc_y * fov_tan
);

// ê´‘ì„  ìƒì„±
ray = { origin: camera.position, direction: ray_dir };
```

---

## ğŸ¯ ê´‘ì„ -ê°ì²´ êµì°¨ ê²€ì‚¬

### 1. ê´‘ì„ -êµ¬ì²´ êµì°¨

êµ¬ì²´: ì¤‘ì‹¬ C, ë°˜ì§€ë¦„ r
ê´‘ì„ : ì›ì  O, ë°©í–¥ D, ê±°ë¦¬ t

**ìˆ˜í•™ì  ì •ì˜**:
```
ì  P = O + t * D ê°€ êµ¬ì²´ ìœ„ì— ìˆë‹¤ë©´:
|P - C|Â² = rÂ²

ì „ê°œ:
|O + tD - C|Â² = rÂ²
(O - C + tD) Â· (O - C + tD) = rÂ²

L = O - C ë¼ê³  í•˜ë©´:
(L + tD) Â· (L + tD) = rÂ²
LÂ·L + 2t(DÂ·L) + tÂ²(DÂ·D) = rÂ²

DëŠ” ë‹¨ìœ„ë²¡í„°ì´ë¯€ë¡œ DÂ·D = 1:
tÂ² + 2t(DÂ·L) + (LÂ·L - rÂ²) = 0
```

**ì´ì°¨ë°©ì •ì‹ í•´**:
```
a = 1
b = 2 * dot(D, L)
c = dot(L, L) - rÂ²

íŒë³„ì‹ Î” = bÂ² - 4ac

if Î” < 0: êµì°¨ ì—†ìŒ
if Î” = 0: í•œ ì ì—ì„œ ì ‘í•¨
if Î” > 0: ë‘ ì ì—ì„œ êµì°¨

t = (-b Â± sqrt(Î”)) / 2a
```

**êµ¬í˜„**:
```c
bool intersect_sphere(ray, sphere, *t_out)
{
    vec3 oc = sub(ray.origin, sphere.center);
    float a = 1.0;  // ray.dir is normalized
    float b = 2.0 * dot(ray.dir, oc);
    float c = dot(oc, oc) - sphere.radius * sphere.radius;
    
    float discriminant = b * b - 4 * a * c;
    if (discriminant < 0)
        return false;
    
    float sqrt_d = sqrt(discriminant);
    float t1 = (-b - sqrt_d) / (2 * a);
    float t2 = (-b + sqrt_d) / (2 * a);
    
    // ê°€ì¥ ê°€ê¹Œìš´ ì–‘ìˆ˜ t ì„ íƒ
    float t = (t1 > 0) ? t1 : t2;
    if (t <= 0)
        return false;
    
    *t_out = t;
    return true;
}
```

### 2. ê´‘ì„ -í‰ë©´ êµì°¨

í‰ë©´: ì  P0, ë²•ì„  N
ê´‘ì„ : ì›ì  O, ë°©í–¥ D

**ìˆ˜í•™ì  ì •ì˜**:
```
í‰ë©´ ìœ„ì˜ ì  PëŠ”:
(P - P0) Â· N = 0

ê´‘ì„  ìœ„ì˜ ì :
P = O + tD

ëŒ€ì…:
(O + tD - P0) Â· N = 0
(O - P0) Â· N + t(D Â· N) = 0

t = -((O - P0) Â· N) / (D Â· N)
```

**êµ¬í˜„**:
```c
bool intersect_plane(ray, plane, *t_out)
{
    float denom = dot(ray.dir, plane.normal);
    
    // ê´‘ì„ ì´ í‰ë©´ê³¼ í‰í–‰
    if (fabs(denom) < EPSILON)
        return false;
    
    vec3 p0_to_origin = sub(plane.point, ray.origin);
    float t = dot(p0_to_origin, plane.normal) / denom;
    
    if (t <= 0)
        return false;
    
    *t_out = t;
    return true;
}
```

### 3. ê´‘ì„ -ì›ê¸°ë‘¥ êµì°¨

ì›ê¸°ë‘¥: ì¤‘ì‹¬ C, ì¶• ë°©í–¥ A, ë°˜ì§€ë¦„ r, ë†’ì´ h

ì›ê¸°ë‘¥ êµì°¨ëŠ” 3ë¶€ë¶„ìœ¼ë¡œ ë‚˜ë‰©ë‹ˆë‹¤:
1. **ì›í†µë©´ (Cylindrical Surface)**
2. **ìƒë‹¨ ìº¡ (Top Cap)**
3. **í•˜ë‹¨ ìº¡ (Bottom Cap)**

#### 3.1 ì›í†µë©´ êµì°¨

```c
// ê´‘ì„ ì„ ì›ê¸°ë‘¥ ì¶• ê¸°ì¤€ìœ¼ë¡œ íˆ¬ì˜
vec3 oc = sub(ray.origin, cylinder.center);
vec3 axis = cylinder.axis;  // ì •ê·œí™”ëœ ì¶• ë°©í–¥

// ì¶• ë°©í–¥ ì„±ë¶„ ì œê±° (2D ì› ë¬¸ì œë¡œ í™˜ì›)
float dot_d_axis = dot(ray.dir, axis);
float dot_oc_axis = dot(oc, axis);

vec3 d_perp = sub(ray.dir, scale(axis, dot_d_axis));
vec3 oc_perp = sub(oc, scale(axis, dot_oc_axis));

// 2D ì›ê³¼ì˜ êµì°¨ (êµ¬ì²´ì™€ ìœ ì‚¬)
float a = dot(d_perp, d_perp);
float b = 2.0 * dot(d_perp, oc_perp);
float c = dot(oc_perp, oc_perp) - cylinder.radius * cylinder.radius;

float discriminant = b * b - 4 * a * c;
if (discriminant < 0)
    return false;

// t ê°’ ê³„ì‚°
float t = (-b - sqrt(discriminant)) / (2 * a);

// ë†’ì´ ì œí•œ í™•ì¸
vec3 hit_point = add(ray.origin, scale(ray.dir, t));
vec3 hit_to_center = sub(hit_point, cylinder.center);
float height_proj = dot(hit_to_center, axis);

if (height_proj < 0 || height_proj > cylinder.height)
    return false;  // ì›í†µë©´ì„ ë²—ì–´ë‚¨
```

#### 3.2 ìº¡ êµì°¨

```c
// ìƒë‹¨ ìº¡ (í‰ë©´ êµì°¨)
vec3 top_center = add(cylinder.center, 
                      scale(axis, cylinder.height));
plane top_cap = { point: top_center, normal: axis };

if (intersect_plane(ray, top_cap, &t))
{
    vec3 hit = add(ray.origin, scale(ray.dir, t));
    vec3 to_center = sub(hit, top_center);
    
    // ì› ì•ˆì— ìˆëŠ”ì§€ í™•ì¸
    if (dot(to_center, to_center) <= cylinder.radius * cylinder.radius)
        return true;  // ìƒë‹¨ ìº¡ì— êµì°¨
}

// í•˜ë‹¨ ìº¡ (ìœ ì‚¬)
```

---

## ğŸ” ìµœê·¼ì ‘ ê°ì²´ ì°¾ê¸°

ëª¨ë“  ê°ì²´ì™€ êµì°¨ ê²€ì‚¬ë¥¼ ìˆ˜í–‰í•˜ê³  ê°€ì¥ ê°€ê¹Œìš´ ê°ì²´ë¥¼ ì„ íƒí•©ë‹ˆë‹¤:

```c
hit_record find_nearest_hit(ray, scene)
{
    hit_record nearest;
    nearest.t = INFINITY;
    nearest.hit = false;
    
    // ëª¨ë“  êµ¬ì²´ ê²€ì‚¬
    for (sphere in scene.spheres)
    {
        float t;
        if (intersect_sphere(ray, sphere, &t) && t < nearest.t)
        {
            nearest.t = t;
            nearest.object = sphere;
            nearest.hit = true;
        }
    }
    
    // ëª¨ë“  í‰ë©´ ê²€ì‚¬
    for (plane in scene.planes) { /* ìœ ì‚¬ */ }
    
    // ëª¨ë“  ì›ê¸°ë‘¥ ê²€ì‚¬
    for (cylinder in scene.cylinders) { /* ìœ ì‚¬ */ }
    
    return nearest;
}
```

---

## âš¡ BVH ìµœì í™”

ë³µì¡í•œ ì¥ë©´ì—ì„œëŠ” ëª¨ë“  ê°ì²´ë¥¼ ê²€ì‚¬í•˜ë©´ ë§¤ìš° ëŠë¦½ë‹ˆë‹¤. BVH(Bounding Volume Hierarchy)ëŠ” ì´ë¥¼ ìµœì í™”í•©ë‹ˆë‹¤.

### BVH ê°œë…

ê°ì²´ë“¤ì„ ê³„ì¸µì  íŠ¸ë¦¬ë¡œ êµ¬ì„±í•˜ì—¬, ê´‘ì„ ì´ ë‹¿ì§€ ì•ŠëŠ” ì˜ì—­ì„ ë¹ ë¥´ê²Œ ì œì™¸í•©ë‹ˆë‹¤.

```
            [ë£¨íŠ¸ AABB]
           /           \
    [ì™¼ìª½ AABB]    [ì˜¤ë¥¸ìª½ AABB]
      /    \          /      \
  [obj1] [obj2]   [obj3]   [obj4]
```

### ê´‘ì„ -AABB êµì°¨

AABB (Axis-Aligned Bounding Box)ëŠ” ì¶•ì— ì •ë ¬ëœ ë°•ìŠ¤ì…ë‹ˆë‹¤:

```c
bool intersect_aabb(ray, aabb)
{
    float t_min = -INFINITY;
    float t_max = INFINITY;
    
    // ê° ì¶•(X, Y, Z)ë§ˆë‹¤
    for (int axis = 0; axis < 3; axis++)
    {
        float inv_d = 1.0 / ray.dir[axis];
        float t0 = (aabb.min[axis] - ray.origin[axis]) * inv_d;
        float t1 = (aabb.max[axis] - ray.origin[axis]) * inv_d;
        
        if (inv_d < 0)
            swap(t0, t1);
        
        t_min = max(t_min, t0);
        t_max = min(t_max, t1);
        
        if (t_max < t_min)
            return false;
    }
    
    return t_max > 0;
}
```

### BVH ìˆœíšŒ

```c
hit_record traverse_bvh(ray, node)
{
    // AABBì™€ êµì°¨í•˜ì§€ ì•Šìœ¼ë©´ ê±´ë„ˆëœ€
    if (!intersect_aabb(ray, node.aabb))
        return NO_HIT;
    
    // ë¦¬í”„ ë…¸ë“œ: ê°ì²´ì™€ ì§ì ‘ êµì°¨ ê²€ì‚¬
    if (node.is_leaf)
        return intersect_object(ray, node.object);
    
    // ë‚´ë¶€ ë…¸ë“œ: ìì‹ ë…¸ë“œ ìˆœíšŒ
    hit_record left_hit = traverse_bvh(ray, node.left);
    hit_record right_hit = traverse_bvh(ray, node.right);
    
    // ê°€ì¥ ê°€ê¹Œìš´ êµì°¨ì  ë°˜í™˜
    return closer_hit(left_hit, right_hit);
}
```

---

## ğŸ”— ê´€ë ¨ ë¬¸ì„œ

- [ì¡°ëª… ì‹œìŠ¤í…œ](ì¡°ëª…-ì‹œìŠ¤í…œ.md)
- [BVH ê°€ì† êµ¬ì¡°](BVH-ê°€ì†-êµ¬ì¡°.md)
- [ê°œë°œ ê°€ì´ë“œ](ê°œë°œ-ê°€ì´ë“œ.md)

---

**Last Updated**: 2026-01-06  
**Version**: 2.0.0
