# ì¡°ëª… ì‹œìŠ¤í…œ

miniRTì˜ ì¡°ëª… ì‹œìŠ¤í…œì€ Phong ë°˜ì‚¬ ëª¨ë¸ì„ ê¸°ë°˜ìœ¼ë¡œ í•˜ë©°, Soft Shadowë¥¼ ì§€ì›í•©ë‹ˆë‹¤.

---

## ğŸ’¡ Phong ì¡°ëª… ëª¨ë¸

Phong ëª¨ë¸ì€ 3ê°€ì§€ ìš”ì†Œë¡œ êµ¬ì„±ë©ë‹ˆë‹¤:

```
ìµœì¢… ìƒ‰ìƒ = Ambient + Diffuse + Specular
```

### 1. Ambient (ì£¼ë³€ê´‘)

í™˜ê²½ì˜ ê°„ì ‘ ì¡°ëª…ì„ ì‹œë®¬ë ˆì´ì…˜í•©ë‹ˆë‹¤. ëª¨ë“  ì ì—ì„œ ë™ì¼í•©ë‹ˆë‹¤.

**ê³µì‹**:
```
I_ambient = K_a Ã— I_a Ã— object_color
```

**ë³€ìˆ˜**:
- `K_a`: ë¬¼ì²´ì˜ ì£¼ë³€ê´‘ ë°˜ì‚¬ ê³„ìˆ˜ (ë³´í†µ 1.0)
- `I_a`: ì£¼ë³€ê´‘ ê°•ë„ (ì”¬ íŒŒì¼ì—ì„œ ì •ì˜)
- `object_color`: ë¬¼ì²´ì˜ ìƒ‰ìƒ

**êµ¬í˜„**:
```c
vec3 calculate_ambient(scene, object)
{
    vec3 ambient_color = scene.ambient.color;
    float ambient_ratio = scene.ambient.ratio;  // 0.0 ~ 1.0
    
    vec3 result = multiply_color(ambient_color, object.color);
    result = scale_color(result, ambient_ratio);
    
    return result;
}
```

### 2. Diffuse (ë‚œë°˜ì‚¬)

Lambertì˜ ì½”ì‚¬ì¸ ë²•ì¹™ì„ ë”°ë¦…ë‹ˆë‹¤. í‘œë©´ì´ ê´‘ì›ì„ ì§ì ‘ í–¥í• ìˆ˜ë¡ ë°ì•„ì§‘ë‹ˆë‹¤.

**ê³µì‹**:
```
I_diffuse = K_d Ã— I_d Ã— (N Â· L) Ã— object_color
```

**ë³€ìˆ˜**:
- `K_d`: ë‚œë°˜ì‚¬ ê³„ìˆ˜ (ë³´í†µ 1.0)
- `I_d`: ê´‘ì›ì˜ ë°ê¸°
- `N`: í‘œë©´ ë²•ì„  (ì •ê·œí™”)
- `L`: êµì°¨ì ì—ì„œ ê´‘ì›ìœ¼ë¡œì˜ ë°©í–¥ (ì •ê·œí™”)
- `N Â· L`: ë‘ ë²¡í„°ì˜ ë‚´ì  (cos Î¸)

**êµ¬í˜„**:
```c
vec3 calculate_diffuse(hit_point, normal, light, object)
{
    // êµì°¨ì ì—ì„œ ê´‘ì›ìœ¼ë¡œì˜ ë°©í–¥
    vec3 light_dir = normalize(sub(light.position, hit_point));
    
    // ë²•ì„ ê³¼ ê´‘ì› ë°©í–¥ì˜ ë‚´ì 
    float diff = dot(normal, light_dir);
    
    // ìŒìˆ˜ëŠ” 0ìœ¼ë¡œ (ë’·ë©´ ì œê±°)
    if (diff < 0)
        diff = 0;
    
    // ì¡°ëª… ìƒ‰ìƒê³¼ ê°ì²´ ìƒ‰ìƒ í˜¼í•©
    vec3 light_color = scale_color(light.color, light.brightness);
    vec3 result = multiply_color(light_color, object.color);
    result = scale_color(result, diff);
    
    return result;
}
```

### 3. Specular (ì •ë°˜ì‚¬)

ê´‘íƒ ìˆëŠ” í‘œë©´ì˜ í•˜ì´ë¼ì´íŠ¸ë¥¼ ì‹œë®¬ë ˆì´ì…˜í•©ë‹ˆë‹¤.

**ê³µì‹**:
```
I_specular = K_s Ã— I_s Ã— (R Â· V)^n Ã— light_color
```

**ë³€ìˆ˜**:
- `K_s`: ì •ë°˜ì‚¬ ê³„ìˆ˜ (ë³´í†µ 0.5)
- `I_s`: ê´‘ì›ì˜ ë°ê¸°
- `R`: ë°˜ì‚¬ ë²¡í„°
- `V`: ì‹œì„  ë²¡í„° (êµì°¨ì ì—ì„œ ì¹´ë©”ë¼ë¡œ)
- `n`: Shininess (ê´‘íƒë„, ë³´í†µ 32)

**ë°˜ì‚¬ ë²¡í„° ê³„ì‚°**:
```
R = 2(N Â· L)N - L
```

**êµ¬í˜„**:
```c
vec3 calculate_specular(hit_point, normal, light, camera)
{
    vec3 light_dir = normalize(sub(light.position, hit_point));
    vec3 view_dir = normalize(sub(camera.position, hit_point));
    
    // ë°˜ì‚¬ ë²¡í„°: R = 2(NÂ·L)N - L
    float nl_dot = dot(normal, light_dir);
    vec3 reflect_dir = sub(
        scale(normal, 2.0 * nl_dot),
        light_dir
    );
    
    // (R Â· V)^n
    float spec = dot(reflect_dir, view_dir);
    if (spec < 0)
        spec = 0;
    
    float shininess = 32.0;
    spec = pow(spec, shininess);
    
    // SpecularëŠ” ê´‘ì› ìƒ‰ìƒë§Œ ì‚¬ìš© (ë¬¼ì²´ ìƒ‰ìƒ ì—†ìŒ)
    vec3 result = scale_color(light.color, light.brightness * 0.5 * spec);
    
    return result;
}
```

### ìµœì¢… ì¡°ëª… ê³„ì‚°

```c
vec3 calculate_lighting(hit_point, normal, object, scene)
{
    vec3 color = vec3(0, 0, 0);
    
    // 1. Ambient
    color = add_color(color, calculate_ambient(scene, object));
    
    // 2. ê·¸ë¦¼ì ì²´í¬
    float shadow_factor = calculate_shadow(hit_point, normal, scene.light);
    
    if (shadow_factor > 0)
    {
        // 3. Diffuse
        vec3 diffuse = calculate_diffuse(hit_point, normal, 
                                         scene.light, object);
        color = add_color(color, scale_color(diffuse, shadow_factor));
        
        // 4. Specular
        vec3 specular = calculate_specular(hit_point, normal, 
                                           scene.light, scene.camera);
        color = add_color(color, scale_color(specular, shadow_factor));
    }
    
    // ìƒ‰ìƒ í´ë¨í•‘ [0, 255]
    color = clamp_color(color);
    
    return color;
}
```

---

## ğŸŒ‘ ê·¸ë¦¼ì ì‹œìŠ¤í…œ

### Shadow Ray

êµì°¨ì ì´ ê´‘ì›ìœ¼ë¡œë¶€í„° ë¹›ì„ ë°›ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤:

```c
bool is_in_shadow(hit_point, light_position, scene)
{
    // êµì°¨ì ì—ì„œ ê´‘ì›ìœ¼ë¡œì˜ ê´‘ì„ 
    vec3 to_light = sub(light_position, hit_point);
    float light_distance = length(to_light);
    vec3 light_dir = normalize(to_light);
    
    // Shadow bias (Shadow Acne ë°©ì§€)
    vec3 shadow_origin = add(hit_point, scale(light_dir, 0.001));
    
    ray shadow_ray = { origin: shadow_origin, direction: light_dir };
    
    // ê´‘ì›ê¹Œì§€ì˜ ê²½ë¡œì— ì¥ì• ë¬¼ì´ ìˆëŠ”ì§€ í™•ì¸
    for (object in scene.objects)
    {
        float t;
        if (intersect(shadow_ray, object, &t))
        {
            // ì¥ì• ë¬¼ì´ ê´‘ì›ë³´ë‹¤ ê°€ê¹Œìš°ë©´ ê·¸ë¦¼ì
            if (t < light_distance)
                return true;
        }
    }
    
    return false;
}
```

### Soft Shadows

ì‹¤ì œ ì„¸ê³„ì˜ ê´‘ì›ì€ ì ì´ ì•„ë‹ˆë¼ ë©´ì ì„ ê°€ì§€ë¯€ë¡œ, ë¶€ë“œëŸ¬ìš´ ê·¸ë¦¼ì ê²½ê³„(penumbra)ê°€ ìƒê¹ë‹ˆë‹¤.

**ì›ë¦¬**: ê´‘ì› ì£¼ë³€ì˜ ì—¬ëŸ¬ ì§€ì ì—ì„œ ìƒ˜í”Œë§í•˜ì—¬ í‰ê· ì„ ëƒ…ë‹ˆë‹¤.

```c
float calculate_soft_shadow(hit_point, normal, light, num_samples)
{
    if (num_samples == 1)
        return is_in_shadow(hit_point, light.position) ? 0.0 : 1.0;
    
    int lit_samples = 0;
    float sample_area = 2.0;  // ê´‘ì› ìƒ˜í”Œë§ ë°˜ê²½
    
    // 4x4 ê·¸ë¦¬ë“œ ìƒ˜í”Œë§
    int samples_per_axis = (int)sqrt(num_samples);
    
    for (int i = 0; i < samples_per_axis; i++)
    {
        for (int j = 0; j < samples_per_axis; j++)
        {
            // ê·¸ë¦¬ë“œ ë‚´ ìƒ˜í”Œ ìœ„ì¹˜ (ê· ë“± ë¶„í¬)
            float u = (i + 0.5) / samples_per_axis;
            float v = (j + 0.5) / samples_per_axis;
            
            // ê´‘ì› ì¤‘ì‹¬ ê¸°ì¤€ ì˜¤í”„ì…‹
            vec3 offset = vec3(
                (u - 0.5) * sample_area,
                (v - 0.5) * sample_area,
                0
            );
            
            // ê´‘ì› ë°©í–¥ì— ìˆ˜ì§ì¸ í‰ë©´ì— ì˜¤í”„ì…‹ ì ìš©
            vec3 light_sample = add(light.position, offset);
            
            // Shadow ray í…ŒìŠ¤íŠ¸
            if (!is_in_shadow(hit_point, light_sample, scene))
                lit_samples++;
        }
    }
    
    // ì¡°ëª…ëœ ìƒ˜í”Œ ë¹„ìœ¨ ë°˜í™˜ (0.0 ~ 1.0)
    return (float)lit_samples / num_samples;
}
```

**í’ˆì§ˆ ì„¤ì •**:
- **ë†’ì€ í’ˆì§ˆ**: 16 samples (4x4) - ì •ì§€ ìƒíƒœ
- **ë‚®ì€ í’ˆì§ˆ**: 1 sample - ì¸í„°ë™ì…˜ ì¤‘

### Shadow Acne ë°©ì§€

êµì°¨ì ê³¼ í‘œë©´ì´ ë„ˆë¬´ ê°€ê¹Œì›Œì„œ ìê¸° ìì‹ ê³¼ êµì°¨í•˜ëŠ” ë¬¸ì œë¥¼ ë°©ì§€í•©ë‹ˆë‹¤.

**ì ì‘í˜• Shadow Bias**:

```c
float calculate_shadow_bias(normal, light_dir)
{
    // í‘œë©´ ê¸°ìš¸ê¸°ì— ë”°ë¼ bias ì¡°ì •
    float cos_angle = dot(normal, light_dir);
    
    // ê¸°ìš¸ì–´ì§„ í‘œë©´ì¼ìˆ˜ë¡ í° bias í•„ìš”
    float base_bias = 0.001;
    float max_bias = 0.01;
    
    // cos_angleì´ ì‘ì„ìˆ˜ë¡ (ê¸°ìš¸ê¸° í´ìˆ˜ë¡) bias ì¦ê°€
    float bias = base_bias + (1.0 - cos_angle) * max_bias;
    
    return bias;
}

vec3 get_shadow_ray_origin(hit_point, normal, light_dir)
{
    float bias = calculate_shadow_bias(normal, light_dir);
    return add(hit_point, scale(normal, bias));
}
```

---

## ğŸ¨ ìƒ‰ìƒ ì²˜ë¦¬

### ìƒ‰ìƒ í˜¼í•©

ë‘ ìƒ‰ìƒì„ ê³±ì…ˆìœ¼ë¡œ í˜¼í•©:

```c
vec3 multiply_color(vec3 c1, vec3 c2)
{
    return vec3(
        c1.x * c2.x / 255.0,
        c1.y * c2.y / 255.0,
        c1.z * c2.z / 255.0
    );
}
```

### ìƒ‰ìƒ í´ë¨í•‘

RGB ê°’ì„ [0, 255] ë²”ìœ„ë¡œ ì œí•œ:

```c
vec3 clamp_color(vec3 color)
{
    return vec3(
        fmin(255.0, fmax(0.0, color.x)),
        fmin(255.0, fmax(0.0, color.y)),
        fmin(255.0, fmax(0.0, color.z))
    );
}
```

### ê°ë§ˆ ë³´ì • (ì„ íƒ)

ì„ í˜• ìƒ‰ê³µê°„ì„ ë””ìŠ¤í”Œë ˆì´ ìƒ‰ê³µê°„ìœ¼ë¡œ ë³€í™˜:

```c
vec3 gamma_correct(vec3 color, float gamma)
{
    return vec3(
        pow(color.x / 255.0, 1.0 / gamma) * 255.0,
        pow(color.y / 255.0, 1.0 / gamma) * 255.0,
        pow(color.z / 255.0, 1.0 / gamma) * 255.0
    );
}
```

---

## ğŸ“Š ì„±ëŠ¥ ê³ ë ¤ì‚¬í•­

### ìƒ˜í”Œë§ ì „ëµ

| ìƒí™© | Soft Shadow Samples | ì´ìœ  |
|------|---------------------|------|
| ì •ì§€ ìƒíƒœ | 16 (4x4) | ë†’ì€ í’ˆì§ˆ |
| í‚¤ ì…ë ¥ ì¤‘ | 1 | ë¹ ë¥¸ ì‘ë‹µ |
| ê°ì²´ ì´ë™ | 4 (2x2) | í’ˆì§ˆê³¼ ì†ë„ ê· í˜• |

### ì¡°ëª… ìºì‹±

ë°˜ë³µ ê³„ì‚°ì„ í”¼í•˜ê¸° ìœ„í•´ ì¼ë¶€ ê°’ì„ ìºì‹±:

```c
typedef struct s_light_cache
{
    vec3    to_light;           // ì •ê·œí™”ëœ ë°©í–¥
    float   distance;           // ê±°ë¦¬
    vec3    scaled_color;       // brightness ì ìš©ëœ ìƒ‰ìƒ
}   t_light_cache;
```

---

## ğŸ”— ê´€ë ¨ ë¬¸ì„œ

- [ë ˆì´ íŠ¸ë ˆì´ì‹± ì•Œê³ ë¦¬ì¦˜](ë ˆì´-íŠ¸ë ˆì´ì‹±-ì•Œê³ ë¦¬ì¦˜.md)
- [BVH ê°€ì† êµ¬ì¡°](BVH-ê°€ì†-êµ¬ì¡°.md)
- [ì”¬ íŒŒì¼ í˜•ì‹](ì”¬-íŒŒì¼-í˜•ì‹.md)

---

**Last Updated**: 2026-01  
**Version**: 2.1.0
