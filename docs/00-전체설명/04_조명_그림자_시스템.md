# 조명 및 그림자 시스템

## 1. Phong 조명 모델

Phong 조명 모델은 3가지 구성 요소로 이루어집니다:
- **Ambient**: 기본 조명 (주변광)
- **Diffuse**: 난반사광
- **Specular**: 정반사광 (하이라이트)

### 1.1 최종 조명 방정식

```
I = Ia + Id × (1 - shadow) + Is × (1 - shadow)
```

```c
t_color apply_lighting(t_scene *scene, t_hit *hit)
{
    t_vec3  light_dir;
    t_vec3  view_dir;
    double  ambient;
    double  diffuse;
    double  specular;
    double  shadow_factor;
    t_color result;

    // 1. Ambient (주변광)
    ambient = scene->ambient.ratio;

    // 2. 벡터 준비
    light_dir = vec3_normalize(
        vec3_subtract(scene->light.position, hit->point));
    view_dir = vec3_normalize(
        vec3_subtract(scene->camera.position, hit->point));

    // 3. Diffuse (난반사)
    diffuse = vec3_dot(hit->normal, light_dir);
    if (diffuse < 0)
        diffuse = 0;

    // 4. Specular (정반사)
    specular = calculate_specular(light_dir, 
                                   hit->normal, 
                                   view_dir) * 0.5;

    // 5. Shadow (그림자)
    shadow_factor = calculate_shadow_factor(scene, 
                                            hit->point,
                                            scene->light.position,
                                            &scene->shadow_config);

    // 6. 최종 조명
    diffuse = (diffuse + specular) * (1.0 - shadow_factor);

    // 7. 색상 계산
    result.r = hit->color.r * (ambient + 
               diffuse * scene->light.brightness);
    result.g = hit->color.g * (ambient + 
               diffuse * scene->light.brightness);
    result.b = hit->color.b * (ambient + 
               diffuse * scene->light.brightness);

    clamp_color(&result);
    return (result);
}
```

## 2. Ambient Light (주변광)

### 2.1 개념
- 간접 조명을 시뮬레이션
- 모든 표면에 균일하게 적용
- 방향 없음

### 2.2 계산
```c
ambient_contribution = object_color × ambient_ratio
```

예시:
```
A 0.2 255,255,255
```
- 비율: 0.2 (20%)
- 색상: 흰색

## 3. Diffuse Reflection (난반사)

### 3.1 Lambert's Cosine Law

```
Diffuse = max(0, N · L)
```
- N: 표면 법선 (정규화)
- L: 광원 방향 (정규화)

### 3.2 물리적 의미
- 광선과 표면이 수직일 때 최대
- 평행할 때 0
- cos(θ)에 비례

### 3.3 구현
```c
double diffuse;

light_dir = vec3_normalize(
    vec3_subtract(light_pos, hit_point));

diffuse = vec3_dot(surface_normal, light_dir);

if (diffuse < 0)
    diffuse = 0;  // 뒷면은 조명 없음
```

### 3.4 시각적 효과
- 표면의 거친 질감 표현
- 부드러운 명암 변화
- 대부분의 현실 물체에 적용

## 4. Specular Reflection (정반사)

### 4.1 Phong Specular Model

```
Specular = (R · V)^n
```
- R: 반사 벡터
- V: 시선 벡터
- n: 광택도 (shininess)

### 4.2 반사 벡터 계산

```
R = 2(N · L)N - L
```

```c
static double calculate_specular(t_vec3 light_dir,
                                  t_vec3 normal,
                                  t_vec3 view_dir)
{
    t_vec3  reflect_dir;
    double  spec;
    double  dot_ln;

    // 1. 반사 벡터 계산
    dot_ln = vec3_dot(light_dir, normal);
    reflect_dir = vec3_subtract(
        vec3_multiply(normal, 2.0 * dot_ln),
        light_dir);

    // 2. 시선과 반사 벡터의 내적
    spec = vec3_dot(reflect_dir, view_dir);
    
    if (spec < 0.0)
        spec = 0.0;

    // 3. 광택도 적용 (32제곱)
    spec = pow(spec, 32.0);

    return (spec);
}
```

### 4.3 광택도 (Shininess)
- 작은 값 (2-10): 무광택 표면
- 중간 값 (20-50): 플라스틱
- 큰 값 (100+): 금속, 거울
- miniRT 사용값: 32

### 4.4 시각적 효과
- 반짝이는 하이라이트
- 매끄러운 표면 표현
- 카메라 위치에 따라 변함

## 5. Soft Shadows (부드러운 그림자)

### 5.1 개념
현실의 그림자:
- **Umbra** (본그림자): 완전히 가려진 영역
- **Penumbra** (반음영): 부분적으로 가려진 영역

### 5.2 다중 샘플링 기법

```c
double calculate_shadow_factor(t_scene *scene,
                                t_vec3 point,
                                t_vec3 light_pos,
                                t_shadow_config *config)
{
    double  shadow_count = 0.0;
    t_vec3  offset;
    t_vec3  sample_light_pos;
    int     i;

    // 샘플 수만큼 반복 (기본 16개)
    i = 0;
    while (i < config->samples)
    {
        // 1. 광원 주변의 샘플 위치 생성
        offset = generate_shadow_sample_offset(
            config->softness * 2.0,
            i,
            config->samples);
        
        sample_light_pos = vec3_add(light_pos, offset);

        // 2. 해당 위치로 그림자 레이 검사
        if (is_in_shadow(scene, point, sample_light_pos, bias))
            shadow_count += 1.0;

        i++;
    }

    // 3. 그림자 비율 계산
    return (shadow_count / (double)config->samples);
}
```

### 5.3 샘플 오프셋 생성

```c
t_vec3 generate_shadow_sample_offset(double radius,
                                      int sample_index,
                                      int total_samples)
{
    t_vec3  offset;
    double  angle;
    double  r;
    int     grid_size;

    if (total_samples <= 1)
        return ((t_vec3){0.0, 0.0, 0.0});

    // 격자 크기 계산
    grid_size = (int)sqrt((double)total_samples);

    // 원형 패턴으로 샘플 분포
    angle = 2.0 * M_PI * (sample_index % grid_size) 
            / (double)grid_size;
    
    r = radius * (sample_index / (double)grid_size + 0.5) 
        / (double)grid_size;

    offset.x = r * cos(angle);
    offset.y = r * sin(angle);
    offset.z = 0.0;

    return (offset);
}
```

### 5.4 그림자 설정

```c
typedef struct s_shadow_config
{
    int     samples;      // 샘플 개수 (1 = 하드, 16+ = 소프트)
    double  softness;     // 부드러움 정도 (0.0 - 1.0)
    double  bias_scale;   // 바이어스 스케일
    int     enable_ao;    // AO 활성화 (미구현)
} t_shadow_config;
```

기본 설정:
```c
config.samples = 16;      // 16개 샘플
config.softness = 0.3;    // 30% 부드러움
config.bias_scale = 2.0;  // 바이어스 배수
```

### 5.5 단일 그림자 레이 검사

```c
int is_in_shadow(t_scene *scene,
                 t_vec3 point,
                 t_vec3 light_pos,
                 double bias)
{
    t_ray   shadow_ray;
    t_hit   shadow_hit;
    t_vec3  to_light;
    t_vec3  light_dir;

    // 1. 광원까지의 벡터
    to_light = vec3_subtract(light_pos, point);
    
    // 2. 거리 저장 (이 거리 이내만 검사)
    shadow_hit.distance = vec3_magnitude(to_light);
    
    // 3. 방향 정규화
    light_dir = vec3_normalize(to_light);

    // 4. 그림자 레이 생성 (bias만큼 떨어진 곳에서 시작)
    shadow_ray.origin = vec3_add(point,
                                 vec3_multiply(light_dir, bias));
    shadow_ray.direction = light_dir;

    // 5. 장애물 검사
    if (check_sphere_shadow(scene, &shadow_ray, &shadow_hit))
        return (1);
    if (check_plane_shadow(scene, &shadow_ray, &shadow_hit))
        return (1);
    if (check_cylinder_shadow(scene, &shadow_ray, &shadow_hit))
        return (1);

    return (0);  // 가림 없음
}
```

## 6. Shadow Acne 방지

### 6.1 문제점
- 표면이 자기 자신을 가리는 현상
- 부동소수점 오차로 인해 발생

### 6.2 해결책: 적응형 바이어스

```c
double calculate_shadow_bias(t_vec3 normal,
                              t_vec3 light_dir,
                              double base_bias)
{
    double  dot_nl;
    double  angle_factor;
    double  bias;

    // 1. 법선과 광선의 내적
    dot_nl = vec3_dot(normal, light_dir);
    if (dot_nl < 0.0)
        dot_nl = -dot_nl;

    // 2. 각도 팩터 계산
    angle_factor = 1.0 - dot_nl;

    // 3. 바이어스 조정
    // 각도가 클수록 (grazing angle) 바이어스 증가
    bias = base_bias * (1.0 + angle_factor * 2.0);

    return (bias);
}
```

### 6.3 바이어스 적용
```c
// 교차점에서 약간 떨어진 곳에서 그림자 레이 시작
shadow_ray.origin = vec3_add(hit_point,
                             vec3_multiply(normal, bias));
```

## 7. 성능 vs 품질 트레이드오프

### 7.1 그림자 품질 설정

| 샘플 수 | 품질 | 렌더링 시간 | 용도 |
|--------|------|------------|------|
| 1 | 하드 그림자 | 빠름 | 프리뷰 |
| 4 | 약간 부드러움 | 보통 | 실시간 |
| 16 | 부드러움 | 느림 | 최종 렌더 |
| 64+ | 매우 부드러움 | 매우 느림 | 고품질 |

### 7.2 최적화 방법

1. **적응형 샘플링**
   - 그림자 경계에만 많은 샘플
   - 구현 복잡도 높음

2. **캐싱**
   - 비슷한 위치는 결과 재사용

3. **공간 분할**
   - 멀리 있는 객체는 그림자 미검사

## 8. 디버깅 및 시각화

### 8.1 각 요소별 렌더링
```c
// Ambient만
color = object_color × ambient_ratio;

// Ambient + Diffuse
color = object_color × (ambient + diffuse);

// 전체 (Ambient + Diffuse + Specular)
color = object_color × (ambient + diffuse + specular);
```

### 8.2 그림자 시각화
```c
// 그림자 팩터를 색상으로
if (shadow_factor > 0.5)
    return RED;   // 그림자
else
    return GREEN; // 밝음
```

### 8.3 법선 시각화
```c
// 법선 벡터를 RGB로
color.r = (normal.x + 1.0) × 127.5;
color.g = (normal.y + 1.0) × 127.5;
color.b = (normal.z + 1.0) × 127.5;
```

## 9. 향후 개선 가능 항목

1. **다중 광원**
   - 여러 개의 점광원 지원

2. **Area Light**
   - 면적 광원으로 더 현실적인 그림자

3. **Global Illumination**
   - 간접 조명 시뮬레이션

4. **Ambient Occlusion**
   - 틈새의 음영 표현

5. **HDR 조명**
   - High Dynamic Range 지원
