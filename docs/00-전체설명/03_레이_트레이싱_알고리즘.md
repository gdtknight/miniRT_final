# 레이 트레이싱 핵심 알고리즘

## 1. 레이 트레이싱 기본 개념

### 1.1 레이(Ray)란?
레이는 시작점(origin)과 방향(direction)을 가진 반직선입니다.

```c
typedef struct s_ray
{
    t_vec3 origin;     // 시작점
    t_vec3 direction;  // 방향 (정규화된 벡터)
} t_ray;
```

### 1.2 레이 방정식
```
P(t) = O + t * D
```
- P(t): t 시점의 점
- O: 시작점 (origin)
- D: 방향 벡터 (direction)
- t: 거리 파라미터 (0 이상)

## 2. 레이-구 교차 검사

### 2.1 수학적 원리

구의 방정식:
```
||P - C||² = r²
```
- P: 구 표면의 점
- C: 구의 중심
- r: 반지름

레이 방정식을 대입:
```
||O + tD - C||² = r²
```

전개하면 2차 방정식:
```
at² + bt + c = 0
```

여기서:
```
a = D·D
b = 2(O-C)·D
c = (O-C)·(O-C) - r²
```

### 2.2 구현 코드

```c
int intersect_sphere(t_ray *ray, t_sphere *sphere, t_hit *hit)
{
    t_vec3  oc;
    double  a, b, c;
    double  discriminant;
    double  t;
    double  radius;

    // 1. 계수 계산
    radius = sphere->diameter / 2.0;
    oc = vec3_subtract(ray->origin, sphere->center);
    
    a = vec3_dot(ray->direction, ray->direction);
    b = 2.0 * vec3_dot(oc, ray->direction);
    c = vec3_dot(oc, oc) - radius * radius;

    // 2. 판별식 계산
    discriminant = b * b - 4 * a * c;
    
    // 교차점 없음
    if (discriminant < 0)
        return (0);

    // 3. 가까운 교차점 선택
    t = (-b - sqrt(discriminant)) / (2.0 * a);
    
    // 음수이면 뒤쪽 교차점 시도
    if (t < 0.001)
        t = (-b + sqrt(discriminant)) / (2.0 * a);

    // 4. 거리 검증
    if (t < 0.001 || t > hit->distance)
        return (0);

    // 5. 교차 정보 저장
    hit->distance = t;
    hit->point = vec3_add(ray->origin, 
                         vec3_multiply(ray->direction, t));
    hit->normal = vec3_normalize(
                    vec3_subtract(hit->point, sphere->center));
    hit->color = sphere->color;
    
    return (1);
}
```

### 2.3 주요 포인트

1. **판별식 (discriminant)**
   - < 0: 교차 없음
   - = 0: 한 점에서 접함
   - > 0: 두 점에서 교차

2. **Epsilon (0.001)**
   - 부동소수점 오차 방지
   - Shadow acne 방지

3. **가까운 교차점 우선**
   - 음의 제곱근 항 먼저 계산
   - 카메라에서 가까운 교차점

## 3. 레이-평면 교차 검사

### 3.1 수학적 원리

평면 방정식:
```
(P - P₀)·N = 0
```
- P: 평면 위의 점
- P₀: 평면 위의 알려진 점
- N: 법선 벡터

레이 방정식 대입:
```
t = (P₀ - O)·N / (D·N)
```

### 3.2 구현 코드

```c
int intersect_plane(t_ray *ray, t_plane *plane, t_hit *hit)
{
    double  denom;
    double  t;
    t_vec3  p0l0;

    // 1. 분모 계산 (레이와 법선의 내적)
    denom = vec3_dot(plane->normal, ray->direction);
    
    // 평행한 경우 (교차 없음)
    if (fabs(denom) < EPSILON)
        return (0);

    // 2. t 계산
    p0l0 = vec3_subtract(plane->point, ray->origin);
    t = vec3_dot(p0l0, plane->normal) / denom;

    // 3. 거리 검증
    if (t < 0.001 || t > hit->distance)
        return (0);

    // 4. 교차 정보 저장
    hit->distance = t;
    hit->point = vec3_add(ray->origin,
                         vec3_multiply(ray->direction, t));
    hit->normal = plane->normal;
    
    // 법선이 레이 반대 방향을 향하도록 조정
    if (vec3_dot(ray->direction, hit->normal) > 0)
        hit->normal = vec3_multiply(hit->normal, -1);
    
    hit->color = plane->color;
    return (1);
}
```

### 3.3 주요 포인트

1. **평행 검사**
   - denom ≈ 0이면 레이와 평면이 평행
   - EPSILON으로 부동소수점 오차 처리

2. **법선 방향 조정**
   - 항상 레이가 오는 쪽을 향하도록
   - 양면 렌더링 효과

## 4. 레이-원기둥 교차 검사

### 4.1 원기둥 구성 요소
1. **측면 (Body)**: 무한 원기둥의 측면
2. **윗면 (Top Cap)**: 원형 디스크
3. **아랫면 (Bottom Cap)**: 원형 디스크

### 4.2 측면 교차 검사

원기둥 측면 방정식 (축 기준):
```
||P - C - ((P-C)·A)A||² = r²
```
- C: 중심
- A: 축 방향 (정규화)
- r: 반지름

레이 대입 후 2차 방정식:
```
a = (D·D) - (D·A)²
b = 2[(D·OC) - (D·A)(OC·A)]
c = (OC·OC) - (OC·A)² - r²
```

```c
static int intersect_cylinder_body(t_ray *ray, 
                                   t_cylinder *cyl, 
                                   t_hit *hit)
{
    t_cyl_calc  calc;
    t_vec3      oc, hit_point, axis_point;
    double      radius;

    // 1. 계수 계산
    radius = cyl->diameter / 2.0;
    oc = vec3_subtract(ray->origin, cyl->center);
    
    calc.a = vec3_dot(ray->direction, ray->direction) -
             vec3_dot(ray->direction, cyl->axis) *
             vec3_dot(ray->direction, cyl->axis);
    
    calc.b = 2.0 * (vec3_dot(ray->direction, oc) -
             vec3_dot(ray->direction, cyl->axis) *
             vec3_dot(oc, cyl->axis));
    
    calc.c = vec3_dot(oc, oc) -
             vec3_dot(oc, cyl->axis) *
             vec3_dot(oc, cyl->axis) -
             radius * radius;

    // 2. 판별식
    calc.discriminant = calc.b * calc.b - 4 * calc.a * calc.c;
    
    if (calc.discriminant < 0 || calc.a < EPSILON)
        return (0);

    // 3. 교차점 거리
    calc.t = (-calc.b - sqrt(calc.discriminant)) / (2.0 * calc.a);
    if (calc.t < 0.001)
        calc.t = (-calc.b + sqrt(calc.discriminant)) / (2.0 * calc.a);

    // 4. 높이 검증
    calc.m = vec3_dot(ray->direction, cyl->axis) * calc.t +
             vec3_dot(oc, cyl->axis);
    
    if (calc.m < -cyl->height/2.0 || calc.m > cyl->height/2.0)
        return (0);

    // 5. 법선 계산 (축 위의 가장 가까운 점 사용)
    hit->distance = calc.t;
    hit->point = vec3_add(ray->origin,
                         vec3_multiply(ray->direction, calc.t));
    
    axis_point = vec3_add(cyl->center,
                         vec3_multiply(cyl->axis, calc.m));
    
    hit->normal = vec3_normalize(
                    vec3_subtract(hit->point, axis_point));
    hit->color = cyl->color;
    
    return (1);
}
```

### 4.3 캡(Cap) 교차 검사

캡은 평면의 원형 영역입니다.

```c
static int intersect_cylinder_cap(t_ray *ray,
                                   t_cylinder *cyl,
                                   t_hit *hit,
                                   double cap_m)
{
    t_vec3  cap_center;
    double  denom, t;
    t_vec3  p;
    double  dist_sq;

    // 1. 평면 교차 검사
    denom = vec3_dot(ray->direction, cyl->axis);
    if (fabs(denom) < EPSILON)
        return (0);

    // 캡 중심 = 원기둥 중심 + 축방향 * cap_m
    cap_center = vec3_add(cyl->center,
                         vec3_multiply(cyl->axis, cap_m));
    
    t = vec3_dot(vec3_subtract(cap_center, ray->origin),
                cyl->axis) / denom;

    if (t < 0.001 || t > hit->distance)
        return (0);

    // 2. 교차점이 원 내부인지 검사
    p = vec3_add(ray->origin, vec3_multiply(ray->direction, t));
    dist_sq = vec3_dot(vec3_subtract(p, cap_center),
                      vec3_subtract(p, cap_center));

    if (dist_sq > (cyl->diameter/2.0) * (cyl->diameter/2.0))
        return (0);

    // 3. 교차 정보 저장
    hit->distance = t;
    hit->point = p;
    hit->normal = cyl->axis;
    
    // 레이 반대 방향으로 법선 조정
    if (vec3_dot(ray->direction, hit->normal) > 0)
        hit->normal = vec3_multiply(hit->normal, -1.0);
    
    hit->color = cyl->color;
    return (1);
}
```

### 4.4 통합 함수

```c
int intersect_cylinder(t_ray *ray, 
                       t_cylinder *cylinder, 
                       t_hit *hit)
{
    int     hit_found = 0;
    t_hit   temp_hit;

    // 1. 측면 검사
    temp_hit.distance = hit->distance;
    if (intersect_cylinder_body(ray, cylinder, &temp_hit))
    {
        *hit = temp_hit;
        hit_found = 1;
    }

    // 2. 윗면 검사
    temp_hit.distance = hit->distance;
    if (intersect_cylinder_cap(ray, cylinder, &temp_hit,
                               cylinder->height / 2.0))
    {
        *hit = temp_hit;
        hit_found = 1;
    }

    // 3. 아랫면 검사
    temp_hit.distance = hit->distance;
    if (intersect_cylinder_cap(ray, cylinder, &temp_hit,
                               -cylinder->height / 2.0))
    {
        *hit = temp_hit;
        hit_found = 1;
    }

    return (hit_found);
}
```

## 5. 최적화 기법

### 5.1 조기 반환 (Early Return)
```c
if (t > hit->distance)
    return (0);  // 이미 더 가까운 교차점 있음
```

### 5.2 거리 정렬
- 가까운 객체부터 검사하면 조기 반환 효과 증대

### 5.3 바운딩 볼륨
- 복잡한 객체를 간단한 경계 박스로 먼저 검사
- 현재 miniRT에는 미구현

## 6. 디버깅 팁

1. **법선 벡터 시각화**
   ```c
   // 법선을 색상으로 변환
   color.r = (int)((normal.x + 1.0) * 127.5);
   color.g = (int)((normal.y + 1.0) * 127.5);
   color.b = (int)((normal.z + 1.0) * 127.5);
   ```

2. **거리 시각화**
   ```c
   // 거리에 따라 밝기 조절
   brightness = 1.0 / (1.0 + distance * 0.1);
   ```

3. **교차 횟수 카운트**
   - 성능 분석용
   - 픽셀당 몇 번의 교차 검사가 수행되는지 확인
