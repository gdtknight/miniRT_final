# miniRT 프로그램 실행 흐름

## 전체 흐름도

```
시작
 ↓
명령행 인자 검증
 ↓
씬 파일 파싱
 ↓
윈도우 초기화
 ↓
렌더링 루프
 ├─ 각 픽셀마다
 │   ├─ 레이 생성
 │   ├─ 객체 교차 검사
 │   ├─ 조명 계산
 │   └─ 색상 결정
 ↓
이벤트 처리 (키보드/마우스)
 ↓
종료
```

## 1. 프로그램 시작 (main.c)

```c
int main(int argc, char **argv)
```

### 1.1 인자 검증
- `argc`가 2인지 확인 (프로그램명 + 씬 파일명)
- 파일 확장자가 `.rt`인지 검증

### 1.2 초기화
```c
t_scene scene;
t_window window;

// 씬 데이터 초기화
init_scene(&scene);
```

## 2. 씬 파일 파싱 (src/parser/)

### 2.1 파일 읽기
```
parse_scene(filename, &scene)
 ↓
파일 열기
 ↓
한 줄씩 읽기
 ↓
줄 타입 판별 (A, C, L, sp, pl, cy)
 ↓
해당 파서 함수 호출
```

### 2.2 지원하는 요소

| 식별자 | 의미 | 파서 함수 |
|-------|------|----------|
| A | Ambient light | `parse_ambient()` |
| C | Camera | `parse_camera()` |
| L | Light | `parse_light()` |
| sp | Sphere | `parse_sphere()` |
| pl | Plane | `parse_plane()` |
| cy | Cylinder | `parse_cylinder()` |

### 2.3 파싱 예시
```
A 0.2 255,255,255
  ↓
ambient.ratio = 0.2
ambient.color = {255, 255, 255}
```

## 3. 윈도우 초기화 (src/window/)

```c
init_window(&window, WIDTH, HEIGHT, "miniRT")
 ↓
mlx_init()                    // MinilibX 초기화
 ↓
mlx_new_window()             // 윈도우 생성
 ↓
mlx_new_image()              // 이미지 버퍼 생성
 ↓
이벤트 핸들러 등록
  - 키 입력: on_keypress()
  - 윈도우 닫기: on_destroy()
```

## 4. 렌더링 메인 루프 (src/render/)

```c
render_scene(&scene, &window)
```

### 4.1 픽셀 순회
```
for y = 0 to HEIGHT:
    for x = 0 to WIDTH:
        ↓
        레이 생성
        ↓
        색상 계산
        ↓
        픽셀에 색상 쓰기
```

### 4.2 레이 생성 과정
```c
create_ray(scene.camera, x, y)
 ↓
NDC 좌표 계산 (0~1 정규화)
 ↓
스크린 좌표 변환
 ↓
레이 방향 벡터 계산
 ↓
t_ray {origin, direction} 반환
```

### 4.3 레이 트레이싱
```c
color = trace_ray(&scene, &ray)
 ↓
교차 검사 (모든 객체)
 ↓
가장 가까운 교차점 찾기
 ↓
조명 계산
 ↓
최종 색상 반환
```

## 5. 교차 검사 (src/ray/intersections.c)

```
trace_ray()
 ↓
hit.distance = INFINITY  // 무한대로 초기화
 ↓
check_sphere_intersections()   // 모든 구 검사
 ↓
check_plane_intersections()    // 모든 평면 검사
 ↓
check_cylinder_intersections() // 모든 원기둥 검사
 ↓
hit_found?
  YES → apply_lighting()
  NO  → return BLACK
```

### 5.1 각 객체별 교차 검사

**구 (Sphere)**
- 2차 방정식 풀이
- 판별식으로 교차 여부 판단

**평면 (Plane)**
- 평면 방정식 사용
- 법선과 레이의 내적 계산

**원기둥 (Cylinder)**
1. 측면(body) 검사
2. 윗면(top cap) 검사
3. 아랫면(bottom cap) 검사
4. 가장 가까운 교차점 선택

## 6. 조명 계산 (src/lighting/)

```c
apply_lighting(&scene, &hit)
 ↓
Ambient 계산
 ↓
Diffuse 계산 (Lambert)
 ↓
Specular 계산 (Phong)
 ↓
그림자 팩터 계산
 ↓
최종 색상 = ambient + (diffuse + specular) × (1 - shadow)
```

### 6.1 그림자 계산
```c
calculate_shadow_factor()
 ↓
for each sample (16개):
    ↓
    샘플 오프셋 생성
    ↓
    그림자 레이 생성
    ↓
    is_in_shadow() 체크
    ↓
    카운트 증가
 ↓
shadow_factor = 가려진 샘플 수 / 전체 샘플 수
```

## 7. 이벤트 처리

### 7.1 키 입력
```c
on_keypress(keycode)
 ↓
ESC (53) → 프로그램 종료
```

### 7.2 윈도우 닫기
```c
on_destroy()
 ↓
cleanup_resources()
 ↓
exit(0)
```

## 8. 프로그램 종료

```c
cleanup()
 ↓
mlx_destroy_image()
 ↓
mlx_destroy_window()
 ↓
free() 동적 할당 메모리
 ↓
exit(0)
```

## 성능 최적화 포인트

1. **조기 반환 (Early Return)**
   - 교차 검사 시 거리가 더 먼 경우 즉시 스킵

2. **그림자 바이어스**
   - Shadow acne 방지
   - 교차점에서 약간 떨어진 위치에서 그림자 레이 시작

3. **캐싱 가능 항목**
   - 정규화된 벡터
   - 반복 계산되는 값들

## 디버깅 팁

1. **픽셀 색상 직접 출력**: 특정 픽셀의 레이 추적 결과 출력
2. **교차점 시각화**: 법선 벡터를 색상으로 변환하여 표시
3. **단계별 테스트**: 조명 없이 → 조명만 → 그림자 추가
