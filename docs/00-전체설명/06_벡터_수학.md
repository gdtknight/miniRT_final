# 벡터 연산 및 수학 라이브러리

## 1. 벡터 구조체

### 1.1 t_vec3 정의

```c
typedef struct s_vec3
{
    double x;
    double y;
    double z;
} t_vec3;
```

3차원 공간의 점 또는 방향을 나타냅니다.

### 1.2 용도
- **점(Point)**: 공간상의 위치
- **벡터(Vector)**: 크기와 방향
- **색상(Color)**: RGB 값 (부동소수점)

## 2. 기본 벡터 연산

### 2.1 벡터 생성

```c
// 직접 생성
t_vec3 v = {1.0, 2.0, 3.0};

// 함수로 생성
t_vec3 create_vector(double x, double y, double z)
{
    t_vec3 v;
    v.x = x;
    v.y = y;
    v.z = z;
    return (v);
}
```

### 2.2 벡터 덧셈

```
v + w = (vx + wx, vy + wy, vz + wz)
```

```c
t_vec3 vec3_add(t_vec3 v, t_vec3 w)
{
    t_vec3 result;

    result.x = v.x + w.x;
    result.y = v.y + w.y;
    result.z = v.z + w.z;

    return (result);
}
```

**용도**:
- 점 이동
- 벡터 합성
- 레이 교차점 계산: `P = O + tD`

### 2.3 벡터 뺄셈

```
v - w = (vx - wx, vy - wy, vz - wz)
```

```c
t_vec3 vec3_subtract(t_vec3 v, t_vec3 w)
{
    t_vec3 result;

    result.x = v.x - w.x;
    result.y = v.y - w.y;
    result.z = v.z - w.z;

    return (result);
}
```

**용도**:
- 두 점 사이의 벡터
- 방향 계산
- 예: `light_dir = light_pos - hit_point`

### 2.4 스칼라 곱

```
k * v = (k·vx, k·vy, k·vz)
```

```c
t_vec3 vec3_multiply(t_vec3 v, double scalar)
{
    t_vec3 result;

    result.x = v.x * scalar;
    result.y = v.y * scalar;
    result.z = v.z * scalar;

    return (result);
}
```

**용도**:
- 벡터 크기 조절
- 레이 전진: `P = O + t*D`
- 색상 조절

### 2.5 스칼라 나눗셈

```
v / k = (vx/k, vy/k, vz/k)
```

```c
t_vec3 vec3_divide(t_vec3 v, double scalar)
{
    t_vec3 result;

    if (fabs(scalar) < EPSILON)
        return (v);  // 0으로 나누기 방지

    result.x = v.x / scalar;
    result.y = v.y / scalar;
    result.z = v.z / scalar;

    return (result);
}
```

## 3. 벡터 내적 (Dot Product)

### 3.1 정의

```
v · w = vx·wx + vy·wy + vz·wz
```

또는:
```
v · w = ||v|| × ||w|| × cos(θ)
```

### 3.2 구현

```c
double vec3_dot(t_vec3 v, t_vec3 w)
{
    return (v.x * w.x + v.y * w.y + v.z * w.z);
}
```

### 3.3 기하학적 의미

- **θ = 0°**: `v · w = ||v|| × ||w||` (같은 방향)
- **θ = 90°**: `v · w = 0` (수직)
- **θ = 180°**: `v · w = -||v|| × ||w||` (반대 방향)

### 3.4 용도

1. **각도 계산**
   ```c
   double cos_theta = vec3_dot(v, w) / 
                      (vec3_magnitude(v) * vec3_magnitude(w));
   ```

2. **투영 (Projection)**
   ```c
   // v를 w에 투영
   double proj_length = vec3_dot(v, w) / vec3_magnitude(w);
   ```

3. **조명 계산 (Lambert)**
   ```c
   double diffuse = vec3_dot(normal, light_dir);
   if (diffuse < 0)
       diffuse = 0;
   ```

4. **평면 방정식**
   ```c
   // 점 P가 평면 위에 있는지 검사
   double dist = vec3_dot(vec3_subtract(P, plane_point), 
                          plane_normal);
   ```

## 4. 벡터 외적 (Cross Product)

### 4.1 정의

```
v × w = (vy·wz - vz·wy,
         vz·wx - vx·wz,
         vx·wy - vy·wx)
```

### 4.2 구현

```c
t_vec3 vec3_cross(t_vec3 v, t_vec3 w)
{
    t_vec3 result;

    result.x = v.y * w.z - v.z * w.y;
    result.y = v.z * w.x - v.x * w.z;
    result.z = v.x * w.y - v.y * w.x;

    return (result);
}
```

### 4.3 특성

1. **수직성**: `v × w`는 `v`와 `w` 모두에 수직
2. **오른손 법칙**: 방향 결정
3. **크기**: `||v × w|| = ||v|| × ||w|| × sin(θ)`
4. **반교환법칙**: `v × w = -(w × v)`

### 4.4 용도

1. **법선 벡터 계산**
   ```c
   // 평면의 법선 = edge1 × edge2
   t_vec3 edge1 = vec3_subtract(p2, p1);
   t_vec3 edge2 = vec3_subtract(p3, p1);
   t_vec3 normal = vec3_normalize(vec3_cross(edge1, edge2));
   ```

2. **좌표계 구성**
   ```c
   // up 벡터로부터 right 벡터 계산
   t_vec3 right = vec3_cross(forward, up);
   ```

3. **면적 계산**
   ```c
   // 삼각형 면적 = ||edge1 × edge2|| / 2
   double area = vec3_magnitude(vec3_cross(edge1, edge2)) / 2.0;
   ```

## 5. 벡터 크기 및 정규화

### 5.1 크기 (Magnitude/Length)

```
||v|| = √(vx² + vy² + vz²)
```

```c
double vec3_magnitude(t_vec3 v)
{
    return (sqrt(v.x * v.x + v.y * v.y + v.z * v.z));
}
```

### 5.2 제곱 크기 (Squared Magnitude)

```c
double vec3_magnitude_squared(t_vec3 v)
{
    return (v.x * v.x + v.y * v.y + v.z * v.z);
}
```

**최적화**: `sqrt()` 계산 생략 가능할 때 사용

### 5.3 정규화 (Normalization)

```
v̂ = v / ||v||
```

```c
t_vec3 vec3_normalize(t_vec3 v)
{
    double  mag;

    mag = vec3_magnitude(v);
    
    // 영벡터 방지
    if (mag < EPSILON)
        return ((t_vec3){0.0, 0.0, 0.0});

    return (vec3_divide(v, mag));
}
```

**용도**:
- 방향 벡터 생성 (크기 = 1)
- 법선 벡터
- 정규화된 레이 방향

### 5.4 거리 계산

```c
double vec3_distance(t_vec3 v, t_vec3 w)
{
    return (vec3_magnitude(vec3_subtract(v, w)));
}
```

## 6. 고급 벡터 연산

### 6.1 반사 벡터 (Reflection)

```
R = I - 2(I·N)N
```
- I: 입사 벡터
- N: 법선 벡터
- R: 반사 벡터

```c
t_vec3 vec3_reflect(t_vec3 incident, t_vec3 normal)
{
    double  dot;
    t_vec3  result;

    dot = vec3_dot(incident, normal);
    result = vec3_subtract(incident,
                          vec3_multiply(normal, 2.0 * dot));

    return (result);
}
```

**용도**: Specular 조명 계산

### 6.2 선형 보간 (Linear Interpolation)

```
lerp(v, w, t) = v + t(w - v) = (1-t)v + tw
```

```c
t_vec3 vec3_lerp(t_vec3 v, t_vec3 w, double t)
{
    return (vec3_add(vec3_multiply(v, 1.0 - t),
                    vec3_multiply(w, t)));
}
```

**용도**:
- 애니메이션
- 색상 그라데이션
- 부드러운 전환

### 6.3 클램핑 (Clamping)

```c
t_vec3 vec3_clamp(t_vec3 v, double min, double max)
{
    t_vec3 result;

    result.x = fmax(min, fmin(max, v.x));
    result.y = fmax(min, fmin(max, v.y));
    result.z = fmax(min, fmin(max, v.z));

    return (result);
}
```

**용도**: 색상 범위 제한

## 7. 색상 연산

### 7.1 색상 구조체 변환

```c
// 정수 색상 → 부동소수점 색상
t_vec3 color_to_vec3(t_color c)
{
    t_vec3 v;

    v.x = c.r / 255.0;
    v.y = c.g / 255.0;
    v.z = c.b / 255.0;

    return (v);
}

// 부동소수점 색상 → 정수 색상
t_color vec3_to_color(t_vec3 v)
{
    t_color c;

    c.r = (int)(fmin(255.0, fmax(0.0, v.x * 255.0)));
    c.g = (int)(fmin(255.0, fmax(0.0, v.y * 255.0)));
    c.b = (int)(fmin(255.0, fmax(0.0, v.z * 255.0)));

    return (c);
}
```

### 7.2 색상 곱셈

```c
t_vec3 color_multiply(t_vec3 c1, t_vec3 c2)
{
    t_vec3 result;

    result.x = c1.x * c2.x;
    result.y = c1.y * c2.y;
    result.z = c1.z * c2.z;

    return (result);
}
```

**용도**: 텍스처 × 조명

## 8. 수학 유틸리티

### 8.1 각도 변환

```c
// 도 → 라디안
double degrees_to_radians(double degrees)
{
    return (degrees * M_PI / 180.0);
}

// 라디안 → 도
double radians_to_degrees(double radians)
{
    return (radians * 180.0 / M_PI);
}
```

### 8.2 클램핑

```c
double clamp(double value, double min, double max)
{
    if (value < min)
        return (min);
    if (value > max)
        return (max);
    return (value);
}
```

### 8.3 비교

```c
// 부동소수점 같음 비교
int float_equals(double a, double b)
{
    return (fabs(a - b) < EPSILON);
}

// 벡터 같음 비교
int vec3_equals(t_vec3 v, t_vec3 w)
{
    return (float_equals(v.x, w.x) &&
            float_equals(v.y, w.y) &&
            float_equals(v.z, w.z));
}
```

## 9. 성능 최적화

### 9.1 인라인 함수

```c
// 간단한 함수는 인라인으로
static inline t_vec3 vec3_add_inline(t_vec3 v, t_vec3 w)
{
    return ((t_vec3){v.x + w.x, v.y + w.y, v.z + w.z});
}
```

### 9.2 제곱근 회피

```c
// 거리 비교 시 제곱 거리 사용
if (vec3_magnitude_squared(v) < radius * radius)
    // 구 내부
```

### 9.3 캐싱

```c
// 반복 사용되는 정규화 벡터 캐싱
t_vec3 light_dir = vec3_normalize(to_light);  // 한 번만 계산
// ... light_dir 여러 번 사용
```

## 10. 디버깅

### 10.1 벡터 출력

```c
void print_vec3(const char *name, t_vec3 v)
{
    printf("%s: (%.3f, %.3f, %.3f)\n", name, v.x, v.y, v.z);
}

void print_vec3_detailed(const char *name, t_vec3 v)
{
    printf("%s: (%.3f, %.3f, %.3f), mag=%.3f\n",
           name, v.x, v.y, v.z, vec3_magnitude(v));
}
```

### 10.2 검증

```c
// 정규화 벡터 검증
int is_normalized(t_vec3 v)
{
    double mag = vec3_magnitude(v);
    return (float_equals(mag, 1.0));
}

// 수직 검증
int is_perpendicular(t_vec3 v, t_vec3 w)
{
    return (float_equals(vec3_dot(v, w), 0.0));
}
```

## 11. 자주 사용되는 벡터 상수

```c
// 기본 방향 벡터
const t_vec3 VEC3_UP      = {0.0, 1.0, 0.0};
const t_vec3 VEC3_DOWN    = {0.0, -1.0, 0.0};
const t_vec3 VEC3_RIGHT   = {1.0, 0.0, 0.0};
const t_vec3 VEC3_LEFT    = {-1.0, 0.0, 0.0};
const t_vec3 VEC3_FORWARD = {0.0, 0.0, -1.0};
const t_vec3 VEC3_BACK    = {0.0, 0.0, 1.0};

// 특수 벡터
const t_vec3 VEC3_ZERO = {0.0, 0.0, 0.0};
const t_vec3 VEC3_ONE  = {1.0, 1.0, 1.0};
```

## 12. 참고: 쿼터니언 (미구현)

회전 표현에 사용 가능:

```c
typedef struct s_quaternion
{
    double w;  // 실수부
    double x;  // i
    double y;  // j
    double z;  // k
} t_quaternion;
```

장점:
- 짐벌락(Gimbal Lock) 없음
- 보간이 쉬움
- 회전 합성이 효율적
