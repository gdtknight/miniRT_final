# 씬 파일 형식 및 파싱

## 1. 씬 파일 (.rt) 형식

### 1.1 기본 구조

씬 파일은 텍스트 파일로, 각 줄은 하나의 요소를 정의합니다.

```
# 주석
A <ambient_ratio> <R,G,B>
C <x,y,z> <nx,ny,nz> <fov>
L <x,y,z> <brightness> <R,G,B>

sp <x,y,z> <diameter> <R,G,B>
pl <x,y,z> <nx,ny,nz> <R,G,B>
cy <x,y,z> <nx,ny,nz> <diameter> <height> <R,G,B>
```

### 1.2 요소 설명

#### Ambient Light (주변광)
```
A 0.2 255,255,255
```
- 식별자: `A`
- 비율: `0.0 ~ 1.0` (조명 강도)
- 색상: `R,G,B` (0-255)
- **필수 요소, 1개만 허용**

#### Camera (카메라)
```
C 0,5,10 0,-0.2,-1 70
```
- 식별자: `C`
- 위치: `x,y,z`
- 방향: `nx,ny,nz` (정규화 필요 없음, 자동 정규화)
- FOV: `0 ~ 180` (시야각, 도 단위)
- **필수 요소, 1개만 허용**

#### Light (광원)
```
L -10,15,10 0.8 255,255,255
```
- 식별자: `L`
- 위치: `x,y,z`
- 밝기: `0.0 ~ 1.0`
- 색상: `R,G,B` (0-255)
- **필수 요소, 1개만 허용**

#### Sphere (구)
```
sp 0,0,0 5.0 255,0,0
```
- 식별자: `sp`
- 중심: `x,y,z`
- 지름: `양수`
- 색상: `R,G,B` (0-255)
- **최대 100개**

#### Plane (평면)
```
pl 0,0,0 0,1,0 200,200,200
```
- 식별자: `pl`
- 점: `x,y,z` (평면 위의 한 점)
- 법선: `nx,ny,nz` (방향 벡터, 자동 정규화)
- 색상: `R,G,B` (0-255)
- **최대 100개**

#### Cylinder (원기둥)
```
cy 0,0,0 0,1,0 2.0 5.0 100,100,255
```
- 식별자: `cy`
- 중심: `x,y,z` (원기둥 중심)
- 축: `nx,ny,nz` (축 방향, 자동 정규화)
- 지름: `양수`
- 높이: `양수`
- 색상: `R,G,B` (0-255)
- **최대 100개**

### 1.3 예제 씬 파일

```rt
# 원기둥 테스트 씬
A 0.15 255,255,255

C 5,5,15 -0.3,-0.2,-1 70

L -10,15,10 0.8 255,255,255

# 빨간 수직 원기둥
cy 0,0,0 0,1,0 2.5 6.0 200,50,50

# 초록 Z축 원기둥
cy -4,0,0 0,0,1 2.0 5.0 50,200,50

# 파란 X축 원기둥
cy 4,0,0 1,0,0 1.5 7.0 50,50,200

# 노란 대각선 원기둥
cy -2,0,4 0.7,0.7,0 1.2 4.0 255,200,0

# 마젠타 구
sp 0,5,0 2.0 255,100,255

# 회색 바닥
pl 0,-3,0 0,1,0 220,220,220

# 연한 파란 배경
pl 0,0,-5 0,0,1 180,200,220
```

## 2. 파싱 프로세스

### 2.1 전체 흐름

```
parse_scene(filename, scene)
  ↓
open_file()
  ↓
while (read_line):
    ↓
    skip_whitespace()
    ↓
    identify_element_type()
    ↓
    call_specific_parser()
    ↓
    validate_parsed_data()
  ↓
close_file()
  ↓
validate_scene()
```

### 2.2 주요 파서 함수

```c
// 메인 파서
int parse_scene(const char *filename, t_scene *scene);

// 각 요소별 파서
int parse_ambient(char *line, t_scene *scene);
int parse_camera(char *line, t_scene *scene);
int parse_light(char *line, t_scene *scene);
int parse_sphere(char *line, t_scene *scene);
int parse_plane(char *line, t_scene *scene);
int parse_cylinder(char *line, t_scene *scene);

// 유틸리티 파서
int parse_vector(char *str, t_vec3 *vec);
int parse_color(char *str, t_color *color);
double ft_atof(const char *str);
```

### 2.3 구체적 파싱 예제

#### 벡터 파싱
```c
int parse_vector(char *str, t_vec3 *vec)
{
    char *ptr = str;

    // x 좌표
    vec->x = ft_atof(ptr);
    
    // 쉼표 찾기
    while (*ptr && *ptr != ',')
        ptr++;
    if (*ptr != ',')
        return (0);
    ptr++;

    // y 좌표
    vec->y = ft_atof(ptr);
    
    // 쉼표 찾기
    while (*ptr && *ptr != ',')
        ptr++;
    if (*ptr != ',')
        return (0);
    ptr++;

    // z 좌표
    vec->z = ft_atof(ptr);

    return (1);
}
```

#### 색상 파싱
```c
int parse_color(char *str, t_color *color)
{
    char *ptr = str;
    int r, g, b;

    // R
    r = ft_atoi(ptr);
    while (*ptr && *ptr != ',')
        ptr++;
    if (*ptr != ',')
        return (0);
    ptr++;

    // G
    g = ft_atoi(ptr);
    while (*ptr && *ptr != ',')
        ptr++;
    if (*ptr != ',')
        return (0);
    ptr++;

    // B
    b = ft_atoi(ptr);

    // 범위 검증
    if (r < 0 || r > 255 || 
        g < 0 || g > 255 || 
        b < 0 || b > 255)
        return (0);

    color->r = r;
    color->g = g;
    color->b = b;

    return (1);
}
```

#### 구 파싱
```c
int parse_sphere(char *line, t_scene *scene)
{
    char        *token;
    t_sphere    *sphere;

    // 개수 제한 체크
    if (scene->sphere_count >= 100)
        return (print_error("Too many spheres"));

    sphere = &scene->spheres[scene->sphere_count];

    // "sp " 건너뛰기
    token = line + 3;
    while (*token == ' ')
        token++;

    // 중심 좌표 파싱
    if (!parse_vector(token, &sphere->center))
        return (print_error("Invalid sphere center"));

    // 다음 토큰으로 이동
    token = skip_to_next_token(token);

    // 지름 파싱
    sphere->diameter = ft_atof(token);
    if (sphere->diameter <= 0)
        return (print_error("Sphere diameter must be positive"));

    // 다음 토큰으로 이동
    token = skip_to_next_token(token);

    // 색상 파싱
    if (!parse_color(token, &sphere->color))
        return (0);

    scene->sphere_count++;
    return (1);
}
```

#### 원기둥 파싱
```c
int parse_cylinder(char *line, t_scene *scene)
{
    char        *token;
    t_cylinder  *cylinder;

    if (scene->cylinder_count >= 100)
        return (print_error("Too many cylinders"));

    cylinder = &scene->cylinders[scene->cylinder_count];

    token = line + 3;
    while (*token == ' ')
        token++;

    // 중심 파싱
    if (!parse_vector(token, &cylinder->center))
        return (print_error("Invalid cylinder center"));

    token = skip_to_next_token(token);

    // 축 방향 파싱
    if (!parse_vector(token, &cylinder->axis))
        return (print_error("Invalid cylinder axis"));
    
    // 축 정규화
    cylinder->axis = vec3_normalize(cylinder->axis);

    token = skip_to_next_token(token);

    // 지름 파싱
    cylinder->diameter = ft_atof(token);
    
    token = skip_to_next_token(token);

    // 높이 파싱
    cylinder->height = ft_atof(token);

    // 크기 검증
    if (cylinder->diameter <= 0 || cylinder->height <= 0)
        return (print_error("Cylinder dimensions must be positive"));

    token = skip_to_next_token(token);

    // 색상 파싱
    if (!parse_color(token, &cylinder->color))
        return (0);

    scene->cylinder_count++;
    return (1);
}
```

## 3. 검증 규칙

### 3.1 필수 요소 검증

```c
int validate_scene(t_scene *scene)
{
    // Ambient light 확인
    if (!scene->has_ambient)
        return (print_error("Missing ambient light"));

    // Camera 확인
    if (!scene->has_camera)
        return (print_error("Missing camera"));

    // Light 확인
    if (!scene->has_light)
        return (print_error("Missing light"));

    // 최소 1개의 객체 확인
    if (scene->sphere_count == 0 && 
        scene->plane_count == 0 && 
        scene->cylinder_count == 0)
        return (print_error("Scene has no objects"));

    return (1);
}
```

### 3.2 값 범위 검증

| 값 | 범위 | 검증 |
|----|------|------|
| Ambient ratio | 0.0 ~ 1.0 | `ratio >= 0 && ratio <= 1` |
| Light brightness | 0.0 ~ 1.0 | `brightness >= 0 && brightness <= 1` |
| FOV | 0 ~ 180 | `fov > 0 && fov < 180` |
| RGB | 0 ~ 255 | `r >= 0 && r <= 255` |
| 지름/높이 | > 0 | `diameter > 0` |

### 3.3 벡터 검증

```c
// 정규화 가능한 벡터인지 확인
int validate_direction(t_vec3 dir)
{
    double magnitude;

    magnitude = vec3_magnitude(dir);
    
    if (magnitude < EPSILON)
        return (0);  // 영벡터

    return (1);
}
```

## 4. 오류 처리

### 4.1 오류 메시지

```c
int print_error(const char *message)
{
    write(STDERR_FILENO, "Error\n", 6);
    write(STDERR_FILENO, message, ft_strlen(message));
    write(STDERR_FILENO, "\n", 1);
    return (0);
}
```

### 4.2 일반적인 오류들

```
Error: Invalid file extension
Error: Cannot open file
Error: Missing ambient light
Error: Missing camera
Error: Missing light
Error: Invalid sphere center
Error: Sphere diameter must be positive
Error: RGB values must be in range [0, 255]
Error: Too many spheres (max 100)
Error: Invalid cylinder axis
Error: Cylinder dimensions must be positive
```

## 5. 유틸리티 함수

### 5.1 문자열 → 실수 변환

```c
double ft_atof(const char *str)
{
    double  result = 0.0;
    double  fraction = 0.0;
    double  divisor = 1.0;
    int     sign = 1;
    int     in_fraction = 0;

    // 부호 처리
    if (*str == '-')
    {
        sign = -1;
        str++;
    }
    else if (*str == '+')
        str++;

    // 정수 부분
    while (*str && *str >= '0' && *str <= '9')
    {
        result = result * 10.0 + (*str - '0');
        str++;
    }

    // 소수점 처리
    if (*str == '.')
    {
        str++;
        in_fraction = 1;
    }

    // 소수 부분
    while (*str && *str >= '0' && *str <= '9')
    {
        divisor *= 10.0;
        fraction = fraction * 10.0 + (*str - '0');
        str++;
    }

    return (sign * (result + fraction / divisor));
}
```

### 5.2 토큰 건너뛰기

```c
static char *skip_to_next_token(char *token)
{
    // 현재 토큰 끝까지
    while (*token && *token != ' ')
        token++;
    
    // 공백 건너뛰기
    while (*token == ' ')
        token++;
    
    return (token);
}
```

## 6. 파싱 디버깅

### 6.1 파싱 결과 출력

```c
void print_scene_info(t_scene *scene)
{
    printf("=== Scene Info ===\n");
    printf("Ambient: ratio=%.2f, color=(%d,%d,%d)\n",
           scene->ambient.ratio,
           scene->ambient.color.r,
           scene->ambient.color.g,
           scene->ambient.color.b);
    
    printf("Camera: pos=(%.2f,%.2f,%.2f), fov=%.1f\n",
           scene->camera.position.x,
           scene->camera.position.y,
           scene->camera.position.z,
           scene->camera.fov);
    
    printf("Light: pos=(%.2f,%.2f,%.2f), brightness=%.2f\n",
           scene->light.position.x,
           scene->light.position.y,
           scene->light.position.z,
           scene->light.brightness);
    
    printf("Spheres: %d\n", scene->sphere_count);
    printf("Planes: %d\n", scene->plane_count);
    printf("Cylinders: %d\n", scene->cylinder_count);
}
```

### 6.2 라인별 디버깅

```c
// 파싱 중 라인 출력
printf("Parsing line: %s\n", line);

// 파싱 결과 출력
printf("Parsed sphere: center=(%.2f,%.2f,%.2f), d=%.2f\n",
       sphere->center.x, sphere->center.y, sphere->center.z,
       sphere->diameter);
```

## 7. 확장 가능성

### 7.1 새로운 객체 추가

1. `objects.h`에 구조체 정의
2. `parse_objects.c`에 파서 함수 추가
3. `parser.c`의 `parse_line()`에 식별자 추가
4. 교차 검사 함수 구현
5. 렌더링 파이프라인에 통합

### 7.2 추가 속성

- 재질 (material): 반사율, 투명도
- 텍스처 (texture): 이미지 매핑
- 변환 (transform): 회전, 크기 조정
- 애니메이션: 시간에 따른 변화
