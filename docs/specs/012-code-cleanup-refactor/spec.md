# 기능 명세서: 코드 정리 및 리팩토링

**기능 브랜치**: `012-code-cleanup-refactor`  
**생성일**: 2026-01-03  
**상태**: 초안  
**입력**: 사용자 설명: "헤더 파일, 소스 파일에 사용되지 않는 함수들, 불필요한 구문들 제거하고 관련성 있는 정의, 구현을 별도의 헤더와 소스 파일로 보기 좋게 구별할 필요가 있음. 너무 중구난방에 정의가 이곳 저곳 섞여있음. 그리고 42 norminette 에 따라 define 구문은 소스 파일에 존재해서는 안됨"

## 사용자 시나리오 및 테스팅 *(필수)*

### User Story 1 - 사용되지 않는 코드 제거 (우선순위: P1)

miniRT 코드베이스를 유지보수하는 개발자로서, 헤더 파일과 소스 파일에서 사용되지 않는 모든 함수와 불필요한 구문을 제거하여 코드베이스를 간결하고 유지보수 가능하며 이해하기 쉽게 만들고 싶습니다.

**우선순위 이유**: 죽은 코드를 제거하는 것은 기초 작업입니다 - 유지보수 부담을 줄이고, 실제로 사용되는 코드에 대한 혼란을 방지하며, 후속 리팩토링을 더 안전하고 명확하게 만듭니다. 이것은 재구성 전에 먼저 수행되어야 합니다.

**독립적 테스트**: 제거 후 프로젝트를 컴파일하고 모든 기존 기능이 여전히 작동하는지 확인하여 완전히 테스트할 수 있습니다 (장면이 올바르게 렌더링되고, 컨트롤이 응답하며, 컴파일 오류가 없음). 코드 복잡성을 줄여 즉각적인 가치를 제공합니다.

**승인 시나리오**:

1. **주어진** 사용되지 않는 함수 선언이 있는 헤더 파일, **할 때** 개발자가 검토하고 제거, **그러면** 프로젝트가 성공적으로 컴파일되고 모든 기존 기능이 작동함
2. **주어진** 사용되지 않는 함수 구현이 있는 소스 파일, **할 때** 개발자가 제거, **그러면** 컴파일 오류가 발생하지 않고 코드 커버리지는 동일하게 유지됨
3. **주어진** 불필요하거나 중복된 구문이 있는 코드, **할 때** 개발자가 제거, **그러면** 프로그램 동작이 변경되지 않음

---

### User Story 2 - 42 Norminette 위반 수정 (우선순위: P1)

42 스쿨 학생으로서, 모든 `#define` 구문을 소스 파일에서 헤더 파일로 이동하여 코드가 42 norminette 규칙을 준수하고 자동 검사를 통과하도록 해야 합니다.

**우선순위 이유**: 42 norminette 준수는 프로젝트 제출을 위한 필수 사항입니다. 이것은 수락을 차단하는 엄격한 요구사항이므로 P1입니다. 재구성이 완료될 필요 없이 독립적으로 테스트할 수 있습니다.

**독립적 테스트**: 모든 소스 파일에서 norminette을 실행하고 `#define` 구문과 관련된 위반이 0개인지 확인하여 완전히 테스트할 수 있습니다. 학교 요구사항 준수를 제공합니다.

**승인 시나리오**:

1. **주어진** `#define` 구문이 포함된 소스 파일, **할 때** 개발자가 적절한 헤더 파일로 이동, **그러면** norminette이 해당 파일에 대해 위반을 표시하지 않음
2. **주어진** 이동된 `#define` 구문을 받는 헤더 파일, **할 때** 개발자가 논리적으로 구성, **그러면** 모든 정의가 헤더 가드로 적절히 보호됨
3. **주어진** 전체 코드베이스, **할 때** norminette 실행, **그러면** `#define` 배치와 관련된 위반이 0개 존재함

---

### User Story 3 - 관련 코드 재구성 (우선순위: P2)

코드베이스를 탐색하는 개발자로서, 관련 정의와 구현을 논리적으로 구성된 헤더/소스 파일 쌍으로 그룹화하여 여러 흩어진 위치를 검색하지 않고도 코드를 빠르게 찾고 이해할 수 있어야 합니다.

**우선순위 이유**: 코드 구성은 장기적인 유지보수성을 향상시키지만 죽은 코드 제거 및 준수 문제 수정 후에 수행할 수 있습니다. 정리 후 남은 것의 전체 범위를 이해해야 합니다.

**독립적 테스트**: 코드베이스에 익숙하지 않은 개발자가 일반적인 작업을 완료하도록 하여 테스트할 수 있습니다 (예: "모든 윈도우 관련 함수 찾기", "벡터 수학 연산 찾기") 및 시간/파일 수 측정. 향상된 개발자 경험을 제공합니다.

**승인 시나리오**:

1. **주어진** 여러 파일에 흩어진 정의, **할 때** 개발자가 기능적 도메인별로 통합, **그러면** 각 헤더/소스 쌍은 관련 기능만 포함함
2. **주어진** 특정 기능 도메인 (예: 벡터 수학, 윈도우 관리), **할 때** 개발자가 관련 코드 검색, **그러면** 모든 관련 코드가 단일 헤더/소스 쌍에서 발견됨
3. **주어진** 새로 구성된 파일, **할 때** 개발자가 기능을 수정해야 함, **그러면** 모든 관련 코드가 한 위치에 있음

---

### User Story 4 - 파일 구성 구조 개선 (우선순위: P3)

코드베이스에서 작업하는 팀으로서, 명확하고 일관된 파일 구성 구조가 필요하므로 모든 개발자가 확립된 패턴을 기반으로 새 코드를 찾거나 추가할 위치를 예측할 수 있습니다.

**우선순위 이유**: 구조적 개선은 장기적인 이점이 있지만 즉각적인 기능이나 준수를 차단하지 않습니다. 이것은 코드가 정리되고 논리적으로 그룹화된 후에 수행되어야 합니다.

**독립적 테스트**: 구성 패턴을 문서화하고 새로운 개발자가 지침 없이 패턴을 따라 코드를 성공적으로 찾거나 추가하도록 하여 테스트할 수 있습니다. 장기적인 확장성을 제공합니다.

**승인 시나리오**:

1. **주어진** 재구성된 코드베이스, **할 때** 새로운 개발자가 참여, **그러면** 파일 명명 규칙에 따라 2분 이내에 특정 기능을 찾을 수 있음
2. **주어진** 구현할 새로운 기능, **할 때** 개발자가 코드를 배치할 위치를 결정, **그러면** 구성 패턴이 올바른 위치를 명확하게 나타냄
3. **주어진** 전체 파일 구조, **할 때** 검토, **그러면** 유사한 기능이 일관된 구성 패턴을 따름

---

### 엣지 케이스

- 함수가 사용되지 않는 것처럼 보이지만 실제로는 함수 포인터나 동적 디스패치를 통해 호출되는 경우 어떻게 되나요?
- 시스템이 여러 소스 파일에서 사용되는 `#define` 구문을 어떻게 처리하나요?
- "사용되지 않는" 코드를 제거하면 헤더 포함 종속성으로 인해 컴파일이 중단되면 어떻게 되나요?
- 파일별 대 프로젝트 전체 `#define` 상수를 어떻게 처리하나요?
- 관련 코드가 여러 추상화 계층에 걸쳐 있을 때 어떻게 되나요 (예: 고수준 렌더링에서 사용되는 저수준 수학)?

## 요구사항 *(필수)*

### 기능적 요구사항

- **FR-001**: 시스템은 코드베이스에 해당 사용이 없는 헤더 파일의 모든 함수 선언을 식별하고 제거해야 함
- **FR-002**: 시스템은 호출되지 않는 소스 파일의 모든 함수 구현을 식별하고 제거해야 함
- **FR-003**: 시스템은 모든 기능적 동작을 보존하면서 불필요한 구문 (중복 코드, 주석 처리된 블록, 죽은 코드 경로)을 제거해야 함
- **FR-004**: 시스템은 소스 파일 (`.c` 파일)의 모든 `#define` 구문을 적절한 헤더 파일 (`.h` 파일)로 이동해야 함
- **FR-005**: 시스템은 이동된 모든 `#define` 구문이 적절한 포함 가드가 있는 헤더에 배치되도록 해야 함
- **FR-006**: 시스템은 관련 정의와 구현을 논리적으로 일관된 헤더/소스 파일 쌍으로 그룹화해야 함
- **FR-007**: 시스템은 기능적 도메인별로 흩어진 정의를 분리해야 함 (예: 벡터 연산, 윈도우 관리, 렌더링, 파싱)
- **FR-008**: 시스템은 각 헤더 파일이 단일 기능적 도메인과 관련된 선언/정의만 포함하도록 해야 함
- **FR-009**: 시스템은 각 소스 파일이 해당 헤더에 선언된 기능만 구현하도록 해야 함
- **FR-010**: 시스템은 모든 기존 기능을 유지해야 함 - 프로그램에 대한 동작 변경 없음
- **FR-011**: 시스템은 `#define` 배치와 관련된 위반이 0개인 상태로 42 norminette 검사를 통과해야 함
- **FR-012**: 시스템은 모든 정리 및 재구성 후 성공적으로 컴파일되어야 함
- **FR-013**: 시스템은 컴파일에 필요한 모든 기존 포함 종속성을 보존해야 함
- **FR-014**: 시스템은 범위 (파일별 대 프로젝트 전체) 및 가시성에 따라 `#define` 상수를 구성해야 함
- **FR-015**: 시스템은 재구성 후 중복 정의가 존재하지 않도록 해야 함
- **FR-016**: 시스템은 42 School 제약사항에 따라 허용된 함수만 사용되는지 검증해야 함 (libc, math.h, mlx_*, libft, get_next_line)
- **FR-017**: 시스템은 재구성 중에 금지된 함수 (pthread, fork, 외부 라이브러리)가 도입되지 않도록 해야 함

### 주요 엔티티 *(기능이 데이터를 포함하는 경우 포함)*

- **헤더 파일 (.h)**: 특정 기능적 도메인에 대한 타입 정의, 매크로, 함수 선언, 구조체 정의를 포함
- **소스 파일 (.c)**: 관련 헤더 파일의 선언에 해당하는 함수 구현을 포함
- **Define 구문**: 42 norminette에 따라 헤더 파일에만 존재해야 하는 전처리기 매크로 정의
- **함수 선언**: 사용될 수도 있고 사용되지 않을 수도 있는 헤더 파일의 함수 프로토타입
- **함수 구현**: 호출될 수도 있고 호출되지 않을 수도 있는 소스 파일의 실제 함수 코드
- **기능적 도메인**: 관련 코드의 논리적 그룹화 (예: 벡터 수학, 윈도우 관리, 레이 트레이싱, 파서)
- **포함 종속성**: 한 파일이 컴파일하기 위해 다른 파일의 정의를 필요로 하는 관계

## 성공 기준 *(필수)*

### 측정 가능한 결과

- **SC-001**: 모든 소스 파일이 `#define` 배치와 관련된 위반이 0개인 상태로 42 norminette 검증을 통과함
- **SC-002**: 모든 변경 후 프로젝트가 경고나 오류 없이 성공적으로 컴파일됨
- **SC-003**: 모든 기존 테스트 케이스가 수정 없이 통과함 (동작 보존)
- **SC-004**: 사용되지 않는 함수 및 불필요한 구문 제거를 통해 코드 라인이 최소 10% 감소함
- **SC-005**: 혼합 도메인 코드를 포함하는 헤더 파일 수가 0으로 감소함 (각 헤더는 단일 책임을 가짐)
- **SC-006**: 개발자가 최대 2개의 파일 (헤더 1개, 소스 1개)을 검사하여 특정 기능적 도메인의 모든 코드를 찾을 수 있음
- **SC-007**: 모든 `#define` 구문이 헤더 파일에만 존재함 (소스 파일에는 0개)
- **SC-008**: 헤더 파일 전체에 중복 함수 선언이 존재하지 않음
- **SC-009**: 동료에 의한 코드 구성 검토가 논리적 그룹화에 대해 90% 동의를 보임
- **SC-010**: 익숙하지 않은 개발자가 특정 기능을 찾는 시간이 최소 40% 감소함
- **SC-011**: 코드베이스에서 사용되는 모든 함수가 42 School 허용 함수 목록에 대해 검증됨 (금지된 함수 0개)
